---
title: "Why are images not displaying in PDFs generated by an Action Controller?"
date: "2024-12-23"
id: "why-are-images-not-displaying-in-pdfs-generated-by-an-action-controller"
---

Alright,  I've seen this particular issue surface more times than I care to recall, and it’s rarely as straightforward as it initially appears. The problem of images not showing up in PDFs generated via an Action Controller is, in my experience, a confluence of factors rather than a singular culprit. We’re not talking about a binary “it works” or “it doesn’t,” but a spectrum of possible configurations and misconfigurations that can lead to this frustrating outcome.

The core of the issue usually lies in how the PDF generation library interacts with your Rails application's asset pipeline and how those assets are ultimately rendered within the PDF. Think of it like this: your Rails app is serving web pages perfectly, images and all, because it's using the asset pipeline to manage and serve those resources. Now, you’re asking a third-party library to take those html structures, and by extension those images, and reproduce them on a different medium - the pdf. It's not a simple copy and paste.

One of the biggest hurdles is that typical PDF generation libraries, such as wkhtmltopdf, prawn, or pdfkit, don't have direct access to the Rails asset pipeline. They’re essentially external applications that are being called by your Ruby code. This means they can't understand asset paths like `/assets/image.png` in the same way your browser does. The problem is often that these paths aren’t absolute. They’re relative to the web server, or even relative to the view's rendering context.

Another common stumbling block revolves around the environment variables and configurations. Sometimes, the environment in which the PDF generation occurs differs from your development environment. This leads to discrepancies in how paths are resolved and whether the necessary assets are even accessible.

Let's delve into specific scenarios and solutions I’ve encountered, focusing on how to resolve them. In each, I'll show code snippets that illustrate concrete scenarios.

**Scenario 1: Relative Asset Paths**

The most frequent issue is the use of relative asset paths within your views that are passed to the PDF generation tool. For instance, you might have an image tag like this:

```erb
<img src="/assets/logo.png">
```

While this works fine when displayed within your browser-rendered html pages, wkhtmltopdf or similar pdf generation processes are unable to resolve the relative path to the web server’s assets folder during rendering.

Here’s how you fix it within the controller:

```ruby
def generate_pdf
  html = render_to_string(template: 'your_template', layout: 'pdf.html.erb', locals: {
  # Pass in the proper asset path. In most cases, the host will need to be set up correctly
  logo_path: "#{request.protocol}#{request.host_with_port}#{ActionController::Base.helpers.asset_path('logo.png')}"
  })

  pdf = WickedPdf.new.pdf_from_string(html)
  send_data pdf, filename: 'your_pdf.pdf', type: 'application/pdf', disposition: 'inline'
end
```

And then, within your ERB view template `your_template.html.erb`:

```erb
<img src="<%= logo_path %>" />
```

The key here is to use the `ActionController::Base.helpers.asset_path` helper in the controller to generate an absolute url for the image. The `request.protocol` and `request.host_with_port` portions create a fully qualified domain name for the asset, ensuring that the pdf generation utility knows exactly where to find it. You'll notice that I have wrapped this in a local variable to be passed in during the render.

**Scenario 2: Missing Asset Directory Access**

Sometimes, the PDF generation library may not have the necessary permissions or access to the asset directory, which can also lead to images not rendering properly. This commonly happens in environments with strict security configurations, or when you’re using a library that requires file system access as opposed to reading from a server’s static location. The approach to fixing it in that case is to pass the directory to be used to lookup the images.

```ruby
def generate_pdf
  html = render_to_string(template: 'your_template', layout: 'pdf.html.erb', locals: {
  # Pass in the correct path. The method will differ based on the library used.
    assets_path: Rails.root.join('public')
  })

  pdf = WickedPdf.new.pdf_from_string(html, :assets_path => locals[:assets_path])
  send_data pdf, filename: 'your_pdf.pdf', type: 'application/pdf', disposition: 'inline'
end
```

And the template `your_template.html.erb` remains the same:

```erb
<img src="<%= logo_path %>" />
```

This method, when used in conjunction with the previous example, makes sure the pdf library is given explicit access to the assets. Note, you need to make sure that whatever tool you are using, in this case `WickedPdf`, supports specifying an assets path during initialisation. Many other PDF generating tools follow a similar convention. You should consult their documentation for specifics on how to use it in your setup.

**Scenario 3: Incorrect HTML Structure**

Occasionally, the culprit isn’t the asset path itself, but the surrounding HTML structure or even CSS that might be interfering with how the image is rendered. PDF generation libraries often have particular quirks, and complex HTML layouts can cause issues. For instance, some libraries can have issues with CSS that is overly complex, or with images that are nested within absolute or fixed positioned elements.

To tackle this, I often implement a simplified layout specifically for PDF generation. This layout will avoid any heavy styling and will make sure images are within non-positioned elements, that way, rendering in the pdf generation tool is as straightforward as possible.

```ruby
# Controller remains similar to the prior example, except for an alternate layout
def generate_pdf
  html = render_to_string(template: 'your_template', layout: 'pdf_simple.html.erb', locals: {
  # Pass in the proper asset path. In most cases, the host will need to be set up correctly
  logo_path: "#{request.protocol}#{request.host_with_port}#{ActionController::Base.helpers.asset_path('logo.png')}"
  })

  pdf = WickedPdf.new.pdf_from_string(html)
  send_data pdf, filename: 'your_pdf.pdf', type: 'application/pdf', disposition: 'inline'
end
```

The template, `pdf_simple.html.erb` will need to be simple:

```erb
<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
    <%= yield %>
  </body>
</html>
```

This layout has deliberately been stripped down to the bare minimum. The template `your_template.html.erb` itself will be largely the same, but the crucial difference is that the simpler layout might solve rendering issues. This approach helps us isolate whether the problem is layout or the asset path itself. If this solves the issue, you know that you need to adjust the styling of the more complex `pdf.html.erb` layout that was used earlier.

In terms of resources for deeper learning, for PDF generation using Ruby on Rails, I recommend investigating these resources:

*   **“Agile Web Development with Rails 7” by David Heinemeier Hansson:** While this is a general Rails book, it covers the asset pipeline in detail and its integration with other Rails components, providing crucial knowledge for understanding how assets are handled in a typical Rails application.

*   **The Official documentation for whichever pdf generation library you're using:** Whether that's `wkhtmltopdf`, `pdfkit`, or `prawn`, their documentation is the best source for understanding how they access assets.

*   **The "Rails Asset Pipeline" Guide:** This official documentation is available on the Ruby on Rails guides and will provide you with specific insight into how assets are compiled, stored, and served.

In conclusion, when you face the challenge of images not appearing in PDFs generated through an Action Controller, it’s almost always down to how you're handling asset paths, access permissions or the complexity of your html layout. Taking a systematic approach, testing each potential issue and systematically addressing them, is crucial to pinpoint the cause and solve the problem efficiently. These are lessons I’ve picked up after many, many hours debugging, and I hope they help you get through this issue quickly and efficiently as well.
