---
title: "How to plot legends in Seaborn KDE plots?"
date: "2024-12-23"
id: "how-to-plot-legends-in-seaborn-kde-plots"
---

Let's tackle the question of legends in Seaborn KDE (Kernel Density Estimate) plots. I remember a particularly thorny project a few years back involving comparing user behavior across different demographic groups, and getting the legends just *so* was crucial for clarity. It’s not always straightforward, especially when you’re dealing with multiple distributions layered on top of each other. So, let's explore the techniques I've found reliable over time.

The core challenge with legends in Seaborn KDE plots often arises because, by default, Seaborn doesn't automatically generate legends for every individual KDE line when using, for example, `sns.kdeplot` directly on a DataFrame. Typically, it's straightforward when you use a 'hue' parameter to distinguish between categories, but when you have several series within the same plot, each generated individually, you have to be a bit more proactive.

Let’s start with the most common scenario where the 'hue' parameter handles legend generation. In this case, you usually want to specify colors for each series, but often Seaborn just handles it. I would have a hypothetical example that reflects something I've seen before.

```python
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Generating some dummy data similar to what I encountered during that project
np.random.seed(42)
data = {
    'group': np.repeat(['group_a', 'group_b', 'group_c'], 100),
    'value': np.concatenate([np.random.normal(0, 1, 100),
                           np.random.normal(2, 1.5, 100),
                           np.random.normal(4, 2, 100)])
}
df = pd.DataFrame(data)

# Now let's create a KDE plot with hue
plt.figure(figsize=(8,6))
sns.kdeplot(data=df, x='value', hue='group', common_norm=False) # Using common_norm=False
plt.title('KDE Plot with Automatic Legend using Hue')
plt.xlabel('Values')
plt.ylabel('Density')
plt.show()

```

This code snippet creates three KDE curves, one for each group ('group_a', 'group_b', 'group_c'), with a legend automatically generated by Seaborn based on the `hue` parameter. Notice that `common_norm=False` prevents normalizing all KDEs, instead normalizing each curve to one. This usually provides better visualization. This is the ideal scenario, and things get slightly more involved when we have separate series we have manually included.

Let’s say, however, that the series aren’t grouped like this. Imagine that the data is being read from a csv that doesn’t necessarily include these group designators. What if instead of a single data frame, the data came as separate series, or separate dataframes for example?

```python
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Generating dummy data, but this time as separate series
np.random.seed(42)
series_a = pd.Series(np.random.normal(0, 1, 100), name='Series A')
series_b = pd.Series(np.random.normal(2, 1.5, 100), name='Series B')
series_c = pd.Series(np.random.normal(4, 2, 100), name='Series C')

plt.figure(figsize=(8,6))
sns.kdeplot(series_a, label='Series A', color='skyblue')
sns.kdeplot(series_b, label='Series B', color='coral')
sns.kdeplot(series_c, label='Series C', color='lightgreen')
plt.title('KDE Plot with Manual Legend')
plt.xlabel('Values')
plt.ylabel('Density')
plt.legend()  # Explicitly call plt.legend() to show legend.
plt.show()

```

Here, we're passing each series to `sns.kdeplot` individually. Critically, we’re using the `label` parameter to give each plot a name and then using `plt.legend()` to render the legend explicitly. Without `plt.legend()`, the labels would not display as a legend. This approach is necessary when you're plotting separate series that aren't easily grouped in a single DataFrame, but it’s important that each line has a label. The `color` parameter here is optional. In this case, these are included to make it obvious which legend is which, but they are not necessary for correct legend output.

Sometimes the desired plot may be more complex than this. Let's suppose the different series are obtained from different dataframes and you want to style them slightly differently to make it even clearer which series is which, and, furthermore, that the labels in the legend need to be customized. This might look like:

```python
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

#Generating dummy data from dataframes
np.random.seed(42)

df_a = pd.DataFrame({'value': np.random.normal(0, 1, 100)})
df_b = pd.DataFrame({'value': np.random.normal(2, 1.5, 100)})
df_c = pd.DataFrame({'value': np.random.normal(4, 2, 100)})


plt.figure(figsize=(8,6))

#Storing the plot so we can get handles
plot_a = sns.kdeplot(data=df_a, x='value', color='skyblue', linestyle='-')
plot_b = sns.kdeplot(data=df_b, x='value', color='coral', linestyle='--')
plot_c = sns.kdeplot(data=df_c, x='value', color='lightgreen', linestyle=':')

#Extract the line objects to use in custom legend
lines = [plot_a.lines[0], plot_b.lines[0], plot_c.lines[0]]
labels = ['Distribution A', 'Distribution B', 'Distribution C']

plt.title('KDE Plot with Custom Legend')
plt.xlabel('Values')
plt.ylabel('Density')
plt.legend(lines, labels) # Explicitly creating the legend using the line objects and custom labels
plt.show()
```

In this example, we’re storing each `sns.kdeplot` result in a variable. This is because `sns.kdeplot` returns an axes object that contains the `lines` attribute. The lines attribute is an array of line2d objects, and in this case, we just want the first line of each kdeplot, so we access using `plot_a.lines[0]` (and so on). This allows us to extract the correct object to use for a custom legend. This is quite powerful and allows for very custom legends. This example also shows the use of linestyle in plotting.

In summary, when working with legends in Seaborn KDE plots, the process largely depends on how your data is structured and how you create the plots. If you have a categorical variable in your DataFrame, the `hue` parameter will make things very straightforward. However, if you have separate series or want to customize the legend further, explicitly using `label` within `sns.kdeplot` and then `plt.legend()` provides the needed control. Alternatively, you can use the resulting axes objects returned by sns.kdeplot to get the underlying objects that need to be in the legend.

For a deeper dive into the technical aspects, I’d recommend examining the matplotlib documentation, specifically the sections concerning legends and line objects. Additionally, the Seaborn documentation is quite good for seeing exactly how different parameters affect legend generation, and I would point towards a book like 'Python Data Science Handbook' by Jake VanderPlas, particularly the sections concerning visualization using Matplotlib and Seaborn. For a theoretical grounding in the statistical background of KDEs, I suggest 'Nonparametric Statistics' by Wasserman. These resources are invaluable for moving beyond basic use and mastering the nuances of plotting libraries in Python.
