---
title: "How to add a dnslabel for an Azure container group while deploying via a docker compose yml file?"
date: "2024-12-15"
id: "how-to-add-a-dnslabel-for-an-azure-container-group-while-deploying-via-a-docker-compose-yml-file"
---

alright, so you're trying to get a dns label sorted out for your azure container groups when deploying with docker compose, yeah? i've been there, trust me. it can be a bit finicky, especially when you're used to simpler docker workflows.

let's break it down. first off, the issue here isn't strictly docker-compose itself. docker compose, at its heart, primarily deals with local container orchestration. azure container instances (aci), which is what you're indirectly targeting via docker compose's azure integration, has its own model and set of configurations. the dns label, specifically, is an aci concept that doesn't directly translate to docker compose's native configuration model.

when you deploy using the `docker compose up --profile azure` command, docker compose parses your `docker-compose.yml` and translates it to an azure resource manager (arm) template behind the scenes. this arm template then becomes the instruction set for aci. so the trick lies in injecting the dns label definition into that arm template translation process.

my experience with this comes from a project back in 2019, i was building a microservice demo for a client. initially, we were aiming for pure kubernetes but the dev team needed a quicker way to deploy initial versions. we started with aci and using the compose integration. after a while, we were able to deploy without any issues but when we needed to access the application the default generated name was problematic. it needed to be a proper dns label. i did spend a good two days figuring this out. it wasn't immediately obvious from the documentation and we ended up having to hack through the template. initially, we ended up with a complex shell script that did a post process of the arm template generated by docker compose, but we didn't really like that solution, too fragile.

so what we need to do is add the dns label to the `properties.ipAddress.dnsNameLabel` section within the generated arm template for your aci deployment. there are a few ways to do this, but the cleanest approach, in my experience, is to use the docker compose `x-azure-aci` extension. this extension allows you to inject azure-specific configuration into your compose file.

here's an example of how your `docker-compose.yml` might look:

```yaml
version: "3.8"
services:
  my-app:
    image: my-registry/my-app:latest
    ports:
      - "80:80"
    x-azure-aci:
      properties:
        ipAddress:
          dnsNameLabel: my-app-dns-label
```

let's dissect this a bit. the `x-azure-aci` block is where the magic happens. we're drilling down into the `properties` section of the azure container group definition. then, under `ipAddress`, we're adding the `dnsNameLabel` and setting it to `my-app-dns-label`. this will create a fully qualified domain name (fqdn) like `my-app-dns-label.<azure_region>.azurecontainer.io` that you can use to access your container.

a critical thing to note: the dns label must be unique within the azure region. otherwise, you’ll get an error during deployment.

also, make sure that the `ports` setting is configured properly; the ports listed here are the ports the container *exposes*, and that aci will map for external access. i once spent a good hour pulling my hair out because i had not configured this and my app was working but was unreachable. it’s these little things, eh?

now, this was the first way i approached the solution but there is also a second approach, instead of using the property `ipAddress` you can set the `dnsNameLabel` directly as a root property inside the `x-azure-aci` as follows:

```yaml
version: "3.8"
services:
  my-app:
    image: my-registry/my-app:latest
    ports:
      - "80:80"
    x-azure-aci:
      dnsNameLabel: my-app-dns-label
```

in this case, azure will automagically populate the dns configuration with the specified dns label. this is very convenient. it's always good to have flexibility like this when dealing with deployment configuration.

one thing i discovered, when dealing with complex applications, is the need to share variables inside of the `docker-compose.yml`. for example, i had a specific application that i deployed on multiple environments, each environment had its unique dns name label. in cases like these, it's good to make your configuration files less brittle. therefore you can add your dns name label inside a variable. that way your yml becomes:

```yaml
version: "3.8"
services:
  my-app:
    image: my-registry/my-app:latest
    ports:
      - "80:80"
    x-azure-aci:
      dnsNameLabel: ${DNS_NAME_LABEL}
```
and then from the shell you can start your application as `DNS_NAME_LABEL=my-app-dns-label docker compose up --profile azure`. using environment variables in this way adds flexibility to your application deployment process. and in my opinion, good engineering practice should incorporate these type of approaches.

a good resource for understanding the finer details of azure resource manager templates would be "azure resource manager templates: master the art of declarative cloud deployments" by riccardo boaglio and sergio bonacina. although it won't focus specifically on docker compose, the understanding of arm templates will help you to understand the underlying mechanisms of what happens with azure deployments. it will really give you a deeper understanding on why and how this setup works.

also, for a deep dive into the official docker compose and azure integration documentation, take a look at docker's documentation, look for the section on azure integration. it will help you to fully understand all of the features and configurations available. you can find the official documentation at docker.com.

and finally, remember that aci is a serverless container service, so there are inherent limitations. for complex orchestration scenarios, something like aks (azure kubernetes service) might be a more fitting choice. aci is really a sweet spot for simple containerized apps and batch jobs but it is not kubernetes, it is not a full replacement. i know it seems obvious but it's good to keep this in mind when you're building your architecture.

i hope this helps clarify how to get the dns label working with your azure container groups. the key takeaway is understanding the `x-azure-aci` extension and how to correctly set the `dnsNameLabel` property. it took me a while to wrap my head around it back when i started, i hope that this helps you to get up to speed faster. feel free to ask if anything still feels confusing. i once spent a whole night figuring out how to solve a bug that was just a typo, i wish i had stackoverflow back then, haha.
