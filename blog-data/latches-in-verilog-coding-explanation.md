---
title: "latches in verilog coding explanation?"
date: "2024-12-13"
id: "latches-in-verilog-coding-explanation"
---

Okay so latches in verilog huh Been there done that got the t-shirt and a few gray hairs to prove it believe me. We all stumble into this trap early on it's like a right of passage in the verilog world. It seems simple enough on the surface but they can bite you hard especially if you’re not careful.

First things first what exactly is a latch. Well in simple words a latch is a memory element that stores a value until its input changes. It’s different from a flip-flop that only changes its output on a clock edge. In verilog if you describe a logic block where a signal’s output isn't assigned under all possible conditions you often unintentionally infer a latch. Think of it as this if a signal doesn't know where to go in every scenario it just kind of sticks to what it had. Not the most elegant way of storing values but it's there.

The core issue is that latches are often created unintentionally. You meant to define a combinational logic block a block whose outputs directly depend on their current inputs and you missed a case. Verilog then sees that some input condition will not lead to an output being defined so it uses a latch to keep that value. Synthesizers usually dont like it very much and for a good reason. They are hard to time especially when you're doing synchronous digital design where everything moves along a clock signal. If you mix asynchronous components like latches into your carefully laid out synchronous design it creates a timing nightmare. Plus if you’re using FPGAs or ASICs latches may have weird effects not present in your simulation and you would wonder what is wrong.

Let’s break this down with some examples. A common offender is incomplete conditional assignment using if statements or case statements.

Here’s a code snippet where we're trying to implement a simple multiplexer using an if statement:

```verilog
module mux_latch(
    input  logic a,
    input  logic b,
    input  logic sel,
    output logic out
);
    always_comb
      if(sel)
         out = a;
    // missing else
endmodule
```

See the problem? if sel is high out becomes a but if sel is low well out is not given any new value and it keeps its old value thus creating a latch. Here is the fix using the else:

```verilog
module mux_no_latch(
    input  logic a,
    input  logic b,
    input  logic sel,
    output logic out
);
    always_comb
      if(sel)
         out = a;
      else
        out = b;
endmodule
```

Much better now we have a mux not a potential headache. The other common case is using case statements. Imagine this. I did that in my first year of university not the best time of my life you can say:

```verilog
module case_latch(
    input  logic [1:0] state,
    output logic [3:0] output_val
);
   always_comb
      case(state)
         2'b00: output_val = 4'b0001;
         2'b01: output_val = 4'b0010;
      endcase
endmodule
```
Again incomplete case. If state is 2’b10 or 2’b11 output_val will retain its previous value. You need to cover all possible cases or define a default to avoid latches. Here’s the corrected version:

```verilog
module case_no_latch(
    input  logic [1:0] state,
    output logic [3:0] output_val
);
   always_comb
      case(state)
         2'b00: output_val = 4'b0001;
         2'b01: output_val = 4'b0010;
         2'b10: output_val = 4'b0100;
         2'b11: output_val = 4'b1000;
         default: output_val = 4'b0000;
      endcase
endmodule
```

I did a whole project once where the top level module was full of these hidden latches. The synthesis tool kept reporting "timing violations" left and right and at that time i had no idea why. Then i spent an entire night staring at waveforms on my logic analyzer finally realizing the problem was these tiny latch time bombs everywhere not clock domain crossing issues. Let me tell you debugging those is not fun. I felt like i was in a bad sci fi movie.

The "always_comb" construct is your friend here it will generate a warning during synthesis if you are creating unintentional latches usually helping with these scenarios. You see when using always_comb the simulator and synthesizers know that every output in it is supposed to be generated by the present inputs and if there is an edge that goes uncovered they will complain about it.

So to avoid this nightmare you must always explicitly assign values to all output signals in your always_comb blocks under every condition. Use else statements with your if blocks and default cases with your case blocks it's as simple as that. Remember verilog isn't just code it's describing hardware so you have to be very explicit about what you want. The tools will do exactly what you tell them even if what you're telling them creates a latch.

Now about resources. Don't bother with online tutorials they usually just scratch the surface or give bad examples. If you want to go deep look at "Digital Design Principles and Practices" by John F. Wakerly. It will give you a real understanding of how digital hardware works. Another good book is "Computer Organization and Design: The Hardware/Software Interface" by Patterson and Hennessy. It focuses on computer architecture but the underlying digital logic principles are the same. You won't find many explicit examples of verilog latches there but they are essential to understanding why you don't want them in your code.

The bottom line latches are a big no no in synchronous designs. Always be very careful when writing conditional logic and you should be fine. If you are doing asynchronous designs be careful in handling them they are way harder to get right. Always check your synthesizer warnings and if something looks too easy it probably is.
