---
title: "What are the key differences between AppConfig and AirWatch SDK approaches for app tunneling?"
date: "2024-12-23"
id: "what-are-the-key-differences-between-appconfig-and-airwatch-sdk-approaches-for-app-tunneling"
---

Okay, let's unpack the AppConfig versus AirWatch SDK approach to app tunneling. I've actually had to navigate this exact decision several times across different projects, each with its own particular constraints and required outcomes, so this isn't just theoretical to me. It's very much grounded in practical experience.

The fundamental goal with either AppConfig or an SDK like AirWatch’s, in the context of app tunneling, is to secure and manage network traffic generated by a mobile application, primarily when accessing internal corporate resources. This typically involves establishing a secure tunnel – usually a vpn connection – that routes app traffic through corporate infrastructure, enforcing access controls and preventing data leakage on potentially untrusted networks. However, these approaches achieve this goal through distinct mechanisms, each with its own set of trade-offs.

AppConfig, at its core, is a framework that relies on a configuration-centric approach. It doesn't actually *do* the tunneling itself. Rather, it provides a standardized way for enterprise mobility management (emm) solutions to deliver configuration information to apps. Think of it as a contract between emm platforms and app developers. For tunneling, this means that an app, when developed, needs to be built in a way that *understands* these configuration parameters. The emm server will then specify things like the tunnel endpoint (the vpn server address), authentication credentials, and sometimes even specific routes or domains that should be funneled through the connection. The app then interprets this configuration and initiates the tunnel using the devices’ native vpn capabilities, or a pre-existing vpn profile.

The advantage of this approach is its relative lightweight nature. There’s no heavy sdk dependency. It works on the principle of least privilege, where the app only takes the essential configuration information without needing access to any other managed functions. The responsibility for establishing the vpn is offloaded to the app, and often the operating system’s native vpn client. This is particularly desirable in organizations where tight control over the app binary itself is preferred. It allows for faster development cycles as minimal changes might be needed to integrate with an enterprise emm.

Contrast this with AirWatch's (now vmware workspace one) sdk. This is a more heavy-handed approach. The airwatch sdk is a substantial library which needs to be included within the app's codebase. It provides a wide range of management features, including not just app tunneling but also app wrapping, secure content management, data loss prevention functionalities, and a whole suite of other functionalities. For app tunneling, the sdk essentially provides its own vpn client, handling the tunnel establishment and management directly. This allows for more granular control over the tunnel, and better integration with AirWatch’s infrastructure. In many ways, the control sits primarily with the sdk itself and emm server, and the app becomes a client of this infrastructure.

The major strength of the sdk approach is the greater level of control and monitoring capabilities offered. The emm platform manages the tunneling process, rather than the app itself. This can lead to more reliable connections, better application analytics, and the opportunity to enforce complex security policies. The integration, however, comes at the cost of increased app size (a sometimes non-trivial factor), and the reliance on a proprietary sdk. This could mean longer development cycles and potential compatibility issues. Also, there's a dependency on maintaining the sdk versions which can add management overhead.

Here's a glimpse at how this plays out in code:

**Example 1: AppConfig-Driven Configuration (Pseudo-code)**

```java
 // Assume configuration is retrieved by the app
 String vpnServerAddress = configManager.getConfigValue("vpn_server_address");
 String username = configManager.getConfigValue("vpn_username");
 String password = configManager.getConfigValue("vpn_password");

 // Initiate VPN connection (using native vpn apis)
 VpnService vpnService = new VpnService();
 vpnService.start(vpnServerAddress, username, password);

 // App continues to function and all traffic will be routed through the tunnel
```

This simplistic example highlights that the app reads the config parameters (retrieved by another process) and uses native api to initiate the vpn connection. The app’s responsibility ends with initiating the connection.

**Example 2: AirWatch SDK Tunneling (Pseudo-code)**

```java
 // AirWatch SDK Initialization and tunnel check
 WorkspaceOneSDK sdk = WorkspaceOneSDK.getInstance();
 sdk.initialize(context);

 boolean tunnelEnabled = sdk.isTunnelEnabled();

 if (tunnelEnabled) {
  // All network calls are automatically tunneled.
 // Make network call that will automatically go over the sdk defined vpn
  NetworkManager.makeHttpRequest("https://internal.company.com/api/data");
 } else {
     // Handle case where tunnel isn't enabled
 }

```

Here the sdk is instantiated and the api handles all the tunneling processes. The app doesn’t need to understand the implementation details of the tunneling. The core point here is that the sdk handles the initiation, maintenance, and routing. The app is not responsible for managing the tunnel itself.

**Example 3: Handling Specific Domains/Routes (pseudo-code, within the app)**

With AppConfig, if you need to only tunnel specific domains (a common security practice), this logic also needs to exist within the application, or within the native vpn layer itself. Here's an example (still conceptually):

```java
    // In an app using appconfig, specific domains will be handled programmatically
    List<String> tunneledDomains = configManager.getConfigValue("tunneled_domains")
    
    // check if current url needs to be tunneled
    if (tunneledDomains.contains(getCurrentUrlDomain(currentNetworkRequest))) {
       // tunnel the request
    } else {
     // make the request outside the tunnel
    }
```
In contrast, with the Airwatch SDK approach, often this granular domain-based routing is configured on the Workspace ONE server, and the sdk handles it transparently without explicit code in the app.

**Summary of key differences:**

*   **Control:** AppConfig delegates tunnel control to the app and the OS, while the AirWatch SDK centralizes it within the SDK and emm platform.
*   **Integration:** AppConfig requires the app to be aware of configuration parameters, the sdk provides integration transparent to the app
*   **Complexity:** AppConfig is relatively lightweight and simpler to integrate for apps, the sdk adds a substantial dependency with greater complexity
*   **Features:** AppConfig’s focus is primarily configuration delivery for tunneling, the sdk is a suite of security and management functionalities
*   **Flexibility:** AppConfig is more flexible in terms of app development and dependencies, while the sdk is more restrictive in terms of requiring a specific sdk.

For a deeper dive, I'd strongly recommend exploring the following resources. For AppConfig, focus on the [AppConfig Community](https://www.appconfig.org) documentation which details the standards and best practices. For more details on enterprise mobility management principles, the book "Enterprise Mobility Management: Securing Corporate Data on Mobile Devices" by Stefan Strobel provides a comprehensive view of the broader landscape. For the VMWare Workspace ONE side of things, dive into the VMWare official documentation for workspace one UEM and the relevant api references for the AirWatch SDK. They have extensive tutorials and guides for their sdk implementation. There are also various publicly available whitepapers on the advantages of each approach that will give a good understanding of use case applicability.

In practice, I've seen both approaches succeed depending on organizational priorities. If you value maximum app control, minimal app bloat, and leverage existing OS vpn capabilities, AppConfig is compelling. If you need robust, centrally managed tunnels with advanced security policies and comprehensive management features, the AirWatch SDK offers more direct control, although it comes with the overhead of the sdk and its complexities. Choose wisely, and consider the specific needs of your environment.
