---
title: "How can Python simulate high ISO noise in images?"
date: "2024-12-23"
id: "how-can-python-simulate-high-iso-noise-in-images"
---

, let’s talk about simulating high iso noise in images using python. I’ve tackled this a few times, particularly during a project involving synthetic dataset generation for a low-light computer vision system. It's not just about adding random pixels; there's a structure to real-world sensor noise that we need to approximate to make it realistic. The key is understanding the various components that contribute to this noise and then implementing them computationally.

When we talk about high iso noise, we’re generally referring to two primary types: shot noise and read noise, along with some variations and nuances. Shot noise, stemming from the discrete nature of light photons, tends to increase with the intensity of the light – more photons mean more potential for variation. Read noise, on the other hand, is generated by the sensor’s electronics during readout and remains relatively constant irrespective of the light level. Now, implementing these noise characteristics in code requires careful attention to how they are modeled mathematically. Simply adding random values won't give you the grainy, mottled texture of an actual high-iso photograph.

My experience suggests we begin with the read noise since it's the simpler of the two. This is typically modeled as additive white gaussian noise. The term 'additive' signifies that this noise is added directly to the pixel values. 'White' means the noise has an even distribution across all frequencies – it's not correlated spatially. And 'gaussian' refers to the characteristic bell-curve shape of the noise distribution. So, we will generate normally distributed random values centered around 0 with a specific standard deviation. This standard deviation is a parameter we can control to simulate different noise levels.

Here's the initial python snippet using numpy to add simulated read noise:

```python
import numpy as np
import cv2

def add_read_noise(image, sigma=10):
    """
    Adds read noise to an image.

    Args:
        image (np.ndarray): The input image as a NumPy array.
        sigma (float): The standard deviation of the gaussian noise.

    Returns:
        np.ndarray: The image with read noise added.
    """
    noisy_image = image.astype(np.float32)
    noise = np.random.normal(0, sigma, image.shape)
    noisy_image += noise
    noisy_image = np.clip(noisy_image, 0, 255).astype(np.uint8) # Clip values to 0-255 range
    return noisy_image


if __name__ == '__main__':
    # Example Usage
    img = cv2.imread("example.jpg") # Replace 'example.jpg' with an actual image file in the same directory
    if img is None:
        print("Error: Could not load image. Please ensure example.jpg exists.")
    else:
        noisy_img = add_read_noise(img, sigma=20)
        cv2.imwrite("noisy_read_noise.jpg", noisy_img)
        print("Image with added read noise saved as noisy_read_noise.jpg")

```

In this snippet, we create a noise array using `np.random.normal` with a mean of 0 and a standard deviation controlled by the `sigma` parameter. The original image is converted to `float32` to avoid clipping issues from adding the noise, then clipped back into a `uint8` representation suitable for images.

Now, let's tackle shot noise, which, as I mentioned, depends on the image signal. Shot noise follows a poisson distribution, however for images, we can generally approximate this with a gaussian distribution whose variance is proportional to the pixel intensity. What this implies is that the standard deviation of the noise increases with the square root of the pixel intensity. We need to simulate that.

Here's a code snippet incorporating both shot and read noise:

```python
import numpy as np
import cv2

def add_combined_noise(image, read_sigma=5, shot_factor=0.02):
    """
    Adds combined read and shot noise to an image.

    Args:
        image (np.ndarray): The input image as a NumPy array.
        read_sigma (float): The standard deviation of the read noise.
        shot_factor (float): Factor controlling the magnitude of shot noise.

    Returns:
         np.ndarray: The image with combined noise added.
    """

    noisy_image = image.astype(np.float32)

    # Read noise
    read_noise = np.random.normal(0, read_sigma, image.shape)
    noisy_image += read_noise

    # Shot Noise (intensity-dependent)
    shot_variance = noisy_image * shot_factor
    shot_noise = np.random.normal(0, np.sqrt(shot_variance), image.shape)
    noisy_image += shot_noise

    noisy_image = np.clip(noisy_image, 0, 255).astype(np.uint8)
    return noisy_image

if __name__ == '__main__':
    # Example usage
    img = cv2.imread("example.jpg") # Replace 'example.jpg' with an actual image file
    if img is None:
        print("Error: Could not load image. Please ensure example.jpg exists.")
    else:
        noisy_img = add_combined_noise(img, read_sigma=15, shot_factor=0.05)
        cv2.imwrite("noisy_combined_noise.jpg", noisy_img)
        print("Image with combined read and shot noise saved as noisy_combined_noise.jpg")

```

In this version, the `shot_factor` controls the strength of shot noise. The shot noise variance is calculated as the pixel value multiplied by this `shot_factor` and standard deviation calculated as the square root of this variance for the generation of noise.

It’s worth noting, in reality, shot noise doesn't perfectly adhere to a gaussian distribution, particularly at lower light levels. The poisson distribution is more accurate, however the gaussian approximation often provides sufficiently realistic results when dealing with high-iso images.

A refinement we might want to add is channel-dependent noise. In real sensors, the red, green, and blue channels often exhibit slightly different noise characteristics. This occurs due to variations in sensor sensitivity and electronic circuitry. Let’s implement a channel-dependent noise version:

```python
import numpy as np
import cv2

def add_channel_dependent_noise(image, read_sigmas=(5, 5, 5), shot_factors=(0.02, 0.02, 0.02)):
    """
    Adds channel-dependent read and shot noise to an image.

    Args:
        image (np.ndarray): The input image as a NumPy array.
        read_sigmas (tuple): Standard deviations for read noise (R, G, B).
        shot_factors (tuple): Factors controlling shot noise magnitude (R, G, B).

    Returns:
         np.ndarray: The image with channel-dependent noise added.
    """
    noisy_image = image.astype(np.float32)

    for channel in range(3): #Loop through R,G,B channels
        channel_img = noisy_image[:, :, channel]
        # Read noise
        read_noise = np.random.normal(0, read_sigmas[channel], channel_img.shape)
        channel_img += read_noise

        # Shot noise
        shot_variance = channel_img * shot_factors[channel]
        shot_noise = np.random.normal(0, np.sqrt(shot_variance), channel_img.shape)
        channel_img += shot_noise

    noisy_image = np.clip(noisy_image, 0, 255).astype(np.uint8)
    return noisy_image

if __name__ == '__main__':
    # Example usage
    img = cv2.imread("example.jpg") # Replace 'example.jpg' with an actual image file
    if img is None:
        print("Error: Could not load image. Please ensure example.jpg exists.")
    else:
         noisy_img = add_channel_dependent_noise(img, read_sigmas=(10, 8, 12), shot_factors=(0.04, 0.03, 0.05))
         cv2.imwrite("noisy_channel_noise.jpg", noisy_img)
         print("Image with channel-dependent noise saved as noisy_channel_noise.jpg")
```

Here, we iterate through each color channel and apply independent read and shot noise parameters. This enables us to simulate a slightly different grain pattern for each channel, as frequently seen in real images. For accurate color noise modelling, a more comprehensive understanding of the particular sensor's characteristics would be beneficial.

For further learning and deeper exploration of this topic, I recommend reading "Digital Image Processing" by Rafael C. Gonzalez and Richard E. Woods. This textbook provides an in-depth treatment of various image noise models. Additionally, the papers on "Noise modeling and estimation of CCD imaging sensors" by J. F. J. van Es and "Image Noise Modelling, Generation and Removal" by David S. Goodenough provide useful frameworks and can enhance understanding of underlying processes. These resources offer the mathematical foundations and algorithms required to really understand and accurately simulate realistic image noise.

Simulating high-iso noise is not an exact science; it's an approximation. However, by carefully modeling the components of real sensor noise, we can create synthetic images that are highly realistic. Start with additive read noise and then incorporate the intensity-dependent shot noise. Adding different noise parameters for each channel provides a final touch to create a realistic noise pattern. Experimentation with the parameters of those functions will be needed to achieve the desired level of realism.
