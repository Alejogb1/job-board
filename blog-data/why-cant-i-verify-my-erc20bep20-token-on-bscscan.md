---
title: "Why can't I verify my ERC20/BEP20 token on BSCScan?"
date: "2024-12-23"
id: "why-cant-i-verify-my-erc20bep20-token-on-bscscan"
---

, let’s get into this. It’s a common headache, this whole “token not verifying” thing on BSCScan, and I’ve seen it trip up many developers, even those quite experienced in other areas. From my own experiences launching a few different projects over the years, I can tell you it’s not always straightforward, and the frustration is entirely understandable. The core issue isn’t usually that the token code *itself* is faulty, but rather a mismatch between what BSCScan expects and what you’re actually feeding it. Let’s dissect why this happens and, more importantly, how to fix it.

Essentially, BSCScan uses an automated process to compile and then compare the deployed bytecode of your contract with the bytecode generated from the source code you provide. If these two match precisely, the verification succeeds. This relies heavily on metadata associated with the solidity compilation process, often overlooked but absolutely critical. Where I've seen things go wrong in the past, there are a few major culprits.

Firstly, the most frequent stumbling block is incorrect compiler settings. Your source code is almost certainly written in solidity, but you need to specify the exact *version* used during compilation. A difference as seemingly insignificant as, say, using `0.8.10` locally while BSCScan’s auto-detector latches onto `0.8.11` will lead to a failed verification. This is because even minor version increments can introduce bytecode variations due to compiler optimizations or internal changes. Moreover, optimization flags play a critical role. If you compiled with optimizations enabled (`solc --optimize`), you must enable the same settings on BSCScan. The ‘runs’ parameter for optimization also affects the output and should be accurately set. Think of it as fine-tuning the compiler, where even minute adjustments have observable effects on the final product.

The other frequent issue, and perhaps the more nuanced, is related to constructor arguments. When you deploy a contract with initial values in the constructor (think token name, symbol, initial supply), those values are encoded directly into the deployed bytecode. If you don’t correctly provide those constructor arguments to BSCScan during verification, the comparison will fail. You're essentially handing BSCScan a compiled file representing only the contract logic and *not* the instantiated state that lives on chain.

Here’s a breakdown of how to tackle this with some examples.

Let’s assume a simple ERC20 token.

**Example 1: Incorrect Compiler Version**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("MyToken", "MTK") {
        _mint(msg.sender, initialSupply);
    }
}
```

If you compiled this with, say, solidity `0.8.12` locally, then attempted to verify with BSCScan assuming it would default to the `^0.8.9` directive in your code, that will fail. BSCScan might choose a slightly different version in that range.

*   **Solution**: You **must** provide the correct version to BSCScan’s verification tool. In the input, choose *'Specify Compiler Version'* and explicitly select `0.8.12`. Furthermore, ensure that if you compiled with optimizations, you mirror these settings within the BSCScan verification UI, including the specific ‘runs’ value.

**Example 2: Missing Constructor Arguments**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MyToken is ERC20 {
    constructor(string memory _name, string memory _symbol, uint256 initialSupply) ERC20(_name, _symbol) {
        _mint(msg.sender, initialSupply);
    }
}
```

If you deployed this with arguments like `"My Awesome Token"`, `"MAT"`, and `1000000000000000000` (representing 1 million tokens with 18 decimals), you cannot just submit the source code to BSCScan. You *must* provide those arguments in their correct encoding (ABI encoded), usually as a hex string. If you don’t, the generated bytecode will be different.

*   **Solution**: After selecting the correct compiler version and optimization settings, there’s usually an input box for constructor arguments. This typically requires you to convert them to an ABI encoded hex string. In this scenario, you would have to:
    1. Use a tool, such as the ethers.js or web3.js libraries, or online resources like the remix IDE's deploy function, to encode your arguments into a hex string. For `"My Awesome Token"`, `"MAT"`, and `1000000000000000000`, using ethers.js would look something like this:
      ```javascript
      const ethers = require('ethers');

      const name = "My Awesome Token";
      const symbol = "MAT";
      const supply = ethers.BigNumber.from("1000000000000000000");

      const abiCoder = ethers.utils.defaultAbiCoder;

      const constructorArgs = abiCoder.encode(['string','string','uint256'], [name,symbol,supply]);
      console.log(constructorArgs);
      ```

    2. You copy the output hex string (`0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000104d7920417765736f6d6520546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044d41540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000de0b6b3a7640000`) to the relevant 'Constructor Arguments' input.

**Example 3: Proxy Contracts and Bytecode Matching**

If you deploy a contract through a proxy, verifying the *proxy* contract using the logic contract code will, of course, fail. The deployed bytecode for a proxy will be completely different.

*   **Solution**: You generally have two choices: either verify the implementation contract (the actual business logic) *separately*, then verify the proxy contract with proxy bytecode, or provide flattened, combined code. This is more of an advanced topic so you’d have to read up on proxy patterns.

For further understanding, I highly recommend reading the official solidity documentation and paying close attention to the section on compiler options and optimization. Also, delving into the *EVM (Ethereum Virtual Machine) Illustrated* by Jacek Sieka (available on Amazon) provides a deeper understanding of how bytecode is structured and executed, which is crucial for pinpointing these problems. A more hands-on resource, *Mastering Ethereum* by Andreas M. Antonopoulos and Gavin Wood, is also invaluable. Understanding the concept of ABI encoding, especially with the help of documentation on ethers.js or web3.js, is also vital for getting constructor arguments right.

In summary, verifying on BSCScan is rarely about a broken token, but almost always about the specific details of your compilation process and deployment. You should pay very close attention to compiler versions, optimization settings, constructor arguments, and the potential use of proxy contracts. It's a bit of a meticulous process, but following these steps methodically will solve the majority of verification issues. Remember, the devil is often in the details when it comes to the EVM.
