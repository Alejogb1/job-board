---
title: "How can I enable SVG file uploads in Wagtail's image section?"
date: "2024-12-23"
id: "how-can-i-enable-svg-file-uploads-in-wagtails-image-section"
---

Let's dive into this, shall we? Handling svg uploads in wagtail’s image section is something I’ve encountered a few times, particularly on projects where we needed vector graphics for crisp display across various screen resolutions. It's a bit of a departure from the standard image formats, and wagtail, out-of-the-box, defaults to handling raster formats primarily. My first experience was, if I’m honest, more about hacking around the edges than a systematic solution. I quickly realized that for a reliable and maintainable implementation, we needed to understand wagtail’s internal image handling mechanisms and extend them appropriately.

The core challenge revolves around wagtail’s `Image` model and its associated validators. By default, it checks for known raster image formats, specifically those within the `PIL` (Pillow) image library's capabilities, and svg falls outside this scope. The initial, naive approach might be to simply bypass these validations. However, that’s neither robust nor good practice because it leaves the door open to uploading all sorts of non-image files masquerading as svgs. So, let’s walk through a more structured approach.

Essentially, we need to do two primary things: first, extend the acceptable file type checks and secondly, potentially introduce custom logic for how these svg files are displayed or handled within wagtail's admin interface. This includes dealing with things like previews which are generated by wagtail.

Let's begin with the file type validation. Wagtail's image handling is governed by the `wagtail.images.models.Image` model. We can't directly modify this, of course, but we can subclass it and override certain aspects.

Here’s an initial code example, showcasing how to extend the `Image` model:

```python
from django.db import models
from wagtail.images.models import Image
from wagtail.images.edit_handlers import ImageChooserPanel
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _
import magic
import io

def validate_svg_mime_type(uploaded_file):
    """Validates if an uploaded file is an svg based on its mime type."""
    try:
        mime = magic.from_buffer(uploaded_file.read(1024), mime=True) #Read first KB of data for filetype check
    except Exception as e:
         raise ValidationError(
            _("Could not determine mime type."), params={"value": str(e)}
        )

    if mime != "image/svg+xml":
        raise ValidationError(
            _("Uploaded file is not an svg."), params={"value": mime}
        )

class CustomImage(Image):
    """Custom image model to allow SVG uploads."""

    def clean(self):
        """
        Overrides the clean method to perform custom validations.
        """
        super().clean()
        if self.file:
            validate_svg_mime_type(self.file)

    admin_form_fields = Image.admin_form_fields + (
        "file", #Ensure the file field is included in admin forms
    )


    panels = [
        ImageChooserPanel("file", heading="Upload SVG Image")
    ]

    class Meta:
       proxy = True #Use this to avoid migrations on the base Wagtail Image Model
```

In this snippet, we've introduced a `CustomImage` model that subclasses Wagtail’s `Image`. The important part is the `clean` method where we’re using the `python-magic` library. The `python-magic` library checks the actual content of the file to determine its mime type rather than relying on potentially misleading file extensions.

The `validate_svg_mime_type` function reads the first 1024 bytes of the uploaded file’s content and validates whether the detected mime type matches `image/svg+xml`. This function provides a better guarantee that only genuine svg files are permitted. Note that `python-magic` is a dependency we need to add to the project’s requirements. You can do this by running `pip install python-magic`.

Now, the above helps us upload, but the admin doesn't render svg's by default. Let's enhance the admin with a custom rendering solution. We’ll achieve this by creating a custom image rendition class:

```python
from wagtail.images.models import AbstractRendition
from django.db import models


class SvgRendition(AbstractRendition):
    """Custom Rendition Model to handle SVGs.

    This rendition handles the creation of a non-resized image, it effectively just renders the original image
    """

    image = models.ForeignKey(
        "CustomImage", on_delete=models.CASCADE, related_name="renditions"
    )

    def render(self, *args, **kwargs):
       # Render the svg without any image manipulation
        return self.image.file.url

    @property
    def url(self):
        #Use the original image URL.
        return self.image.file.url


    def get_view_name(self):
      return 'wagtailimages_serve_svg_rendition'


    class Meta:
        unique_together = ("image", "file") # Unique relation between the Image and its original file


def get_svg_rendition_model():
    return SvgRendition
```

This `SvgRendition` model will render the svg files using the original svg’s url. It's essential to register this custom rendition model with wagtail's image settings in your settings file.

```python
# In your settings.py or a dedicated settings file for Wagtail

WAGTAILIMAGES_RENDITION_MODEL = "your_app_name.get_svg_rendition_model"
```
Replace `your_app_name` with the actual name of the application where you defined these models.

The final piece is handling the serving of these svg's. Typically, wagtail generates resized renditions, but for svgs, we generally want to serve the original file and potentially use css for sizing. We'll create a custom serve view for the rendition model:

```python
from django.http import FileResponse
from django.shortcuts import get_object_or_404
from django.views.generic import View


class ServeSvgRendition(View):
    """ Custom view to serve SVGs. """

    def get(self, request, rendition_id, *args, **kwargs):
        rendition = get_object_or_404(SvgRendition, id=rendition_id)
        return FileResponse(
            rendition.image.file.open("rb"), content_type="image/svg+xml"
        )


#In your app's urls.py
from django.urls import path
from .views import ServeSvgRendition

urlpatterns = [
    path("rendition/<int:rendition_id>/", ServeSvgRendition.as_view(), name="wagtailimages_serve_svg_rendition"),
]
```
This custom view retrieves the corresponding `SvgRendition` object and returns the original file via a `FileResponse` with the correct mime type. We also need to register this view with a custom url pattern. Please note that this pattern must correspond with the value we gave to the `get_view_name` method within the `SvgRendition` model.

Finally, in order to ensure that our custom `CustomImage` model is used by wagtail, we also need to set this in our app settings, in your settings.py

```python
WAGTAILIMAGES_IMAGE_MODEL = 'your_app_name.CustomImage'
```
Again replacing `your_app_name` with your app's name.

Putting it all together: we've effectively extended wagtail’s image handling to accept svg files, validated the files, created a custom rendition model that serves the original file, and wired up a dedicated view for serving these svg files.

A few key things to bear in mind:

*   **Security:** Always validate the svg files server-side, do not just rely on the client. Malicious svgs can contain embedded scripts that can compromise the client's browser. Consider additional sanitization if your security posture requires it.
*   **Scalability:** This method is suitable for most use cases. But if you have a very high throughput of svg uploads, consider techniques like caching or dedicated image servers.
*   **File Handling:**  Be mindful of file system permissions. Ensure that the user running the django application has appropriate read access to the storage location for the images.

For further reading, I highly recommend “*Programming in HTML5 with JavaScript and CSS3*” by David Geary for understanding the intricacies of svg and how to best use it within web development contexts. For a more thorough grasp of file handling and mime types within python, reviewing the documentation of the `magic` library alongside the standard `io` library is invaluable. For a deep understanding of how django handles files and media storage, refer to the official Django documentation related to files and storage. Additionally, Wagtail’s official documentation and source code are fundamental for truly grasping how its image handling is implemented and how you can extend it.
This approach, in my experience, provides a solid foundation for managing svg uploads in Wagtail. It strikes a good balance between security, functionality, and maintainability. Remember that these code snippets serve as a foundational starting point, and you should adapt them to fit the specific needs and context of your application.
