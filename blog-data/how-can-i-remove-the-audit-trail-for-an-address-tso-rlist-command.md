---
title: "How can I remove the audit trail for an ADDRESS TSO RLIST command?"
date: "2024-12-23"
id: "how-can-i-remove-the-audit-trail-for-an-address-tso-rlist-command"
---

Alright,  It’s a question I’ve seen pop up in various forms over the years, and it's a good one, touching on both operational needs and underlying z/os principles. The need to remove audit trails, specifically those generated by `address tso rlist` commands, often stems from very specific scenarios. For example, in my past life, while optimizing batch job performance for a large financial institution, we had a peculiar situation where these audit records were actually *hindering* our investigation into bottlenecks, generating so much noise that the valuable data was lost in the deluge. That's when I started looking at this question with an open mind: how can we effectively manage and sometimes suppress this data flow?

The short answer? Directly suppressing the audit trail for `address tso rlist` as a generic command is not straightforward, and that's largely by design. z/os is built to maintain audit logs for a very good reason. However, what *is* within reach are techniques to manage, filter, and post-process the audit logs to achieve your specific goal. We're not going to bypass or break system security, which is the last thing anyone wants. Instead, we'll look at methods that allow us to selectively deal with the logging.

First, let's break down why `address tso rlist` generates audit trails in the first place. These commands, when issued under a TSO environment, often involve data retrieval or operations on datasets and thus are subject to logging and security checks. z/os records these events through its System Management Facility (SMF) data stream, which is typically written to various system datasets. The SMF records include information such as the user ID, the time of the command execution, and specifics about the resources accessed. The `rlist` command is of specific interest to systems programmers because it can quickly expose the security authorizations to certain datasets which could have a security risk if exposed.

Therefore, if we can’t directly stop this, the strategy shifts to managing this data output effectively. Here are a few approaches I have employed and found useful, which are based on what I’ve seen in practice.

**1. Filtering via SMF Parameters:**

One powerful way to reduce the log 'noise' is to use SMF recording parameters to filter out specific event types. You're not removing the audit trail entirely for `address tso rlist`, but rather preventing *some* of the records from being generated or written to the main system logs. This is usually done at the system level within parmlib members such as SMFPRMxx. Here is how you might modify the `SMFPRMxx` member:

```jcl
//SYSIN DD *
  OPTIONS(NODUP)
  SYS(TYPE(0:255),
  NOTYPE(8, 9, 14, 15, 16, 17, 30, 32, 42, 60, 62, 64, 66, 82, 85, 90,
  92, 95, 96, 98, 100, 102, 106, 108, 110, 111, 114, 115, 116, 120, 123, 124, 128,
  130, 132, 140, 142, 144, 146, 154, 166, 174, 190, 191, 204, 206, 212, 220, 230))
/*
```

In this snippet, `TYPE` specifies which records to *include*, while `NOTYPE` specifies which to *exclude*. You would include the SMF record type associated with the specific `rlist` output. You'd need to investigate the relevant SMF record type. Typically, security-related events will be in type 80 or 81, but this is often controlled by your installation’s security software. The snippet above shows *excluding* a large number of smf record types. Please be aware that modifying the `NOTYPE` parameter should be performed with utmost caution, with a thorough understanding of the impact for other components of your system. If you were to *include* just a few record types, you would have to remove or comment out the `NOTYPE` parameter and *include* only the record types of interest. This method does require an IPL or an `smf refresh` command to take effect. Furthermore, this affects the entire system, so careful planning is paramount.

**2. Post-Processing with SMF Data Analysis Tools:**

Another approach is to capture all SMF records and then filter or process them offline. This can be done via tools such as SAS or MXG, which are data analysis suites that specialize in reading SMF records and allows us to further process and analyze the data. Let's assume we are using SAS, here’s a high-level representation of how the SAS code might look to remove records generated by TSO address command for reporting:

```sas
data smf_filtered;
  set smf_raw; /*Assumes the SMF data is previously imported*/
  where smf_type = 80 /* Assuming security records are type 80 */
  and index(lower(smf_command_line), 'address tso rlist') = 0; /*filters out any records with 'address tso rlist'*/
run;

proc print data = smf_filtered;
run;
```

In the example above, we're setting a dataset called `smf_filtered`, from a larger dataset called `smf_raw`, and then filtering this to only include security-related SMF records that do not contain `address tso rlist` in their command lines. This assumes that you have a dataset available of SMF records, which is normally output by your system’s SMF data collection process. The next `proc print` simply displays the data, but you could then use these records for further analysis or store them in a different location. With this approach, you are creating an audit trail but it’s filtered to your needs. This also is valuable if you have an archive of SMF data and wish to review the historical data. This method is excellent when analysis of data is required instead of complete deletion.

**3. Using z/os Auditing APIs (Less Common, Highly Specific):**

While not a direct solution to suppress `rlist` audit trails, it's useful to know that z/os offers an API (application programming interface) for auditing. You *could* use this API to potentially control how audit events are generated if you write your own programs or exits. For example, you could intercept and filter specific events *before* they reach the SMF stream, although this is an advanced tactic, and I personally would only consider it for very unique and justified edge cases. It could, for instance, involve using the RACF (Resource Access Control Facility) callable services to programmatically filter auditing events. Such an exit would be complex, so a simple code representation is not appropriate here.

When you have a custom auditing system, you have control over what will be logged. The specific details for this API call can be found in IBM’s documentation on z/os security, specifically on RACF and system auditing. This route should only be considered if all other methods are not suitable. For this method, a good reference is “*IBM z/os Security Server RACF Callable Services*”, which you can find in the IBM documentation library. The IBM documentation on z/os is comprehensive and would be the most authoritative source.

**Conclusion and Recommendations:**

While there’s no simple switch to completely remove `address tso rlist` audit trails, these methods – filtering, post-processing, and the use of the auditing API – give us workable solutions. The most practical approach for most situations, is to use some combination of SMF recording parameters and post-processing analysis, as described in points 1 and 2. Direct control via auditing APIs (point 3) is highly specialized, usually unnecessary, and should be considered the most extreme solution.

Remember, the goal should be to manage the audit trails effectively, not to eliminate them entirely. For detailed specifics about SMF records and their filtering, IBM documentation is indispensable. Specifically, consult the "z/os MVS System Management Facilities" manuals and also relevant documentation on specific security software, such as RACF.

The key is to choose the method or combination of methods that best aligns with your specific needs and resources. And as always, be careful when dealing with security auditing data and make sure you completely understand what you are modifying and always, *always*, test thoroughly. Good luck!
