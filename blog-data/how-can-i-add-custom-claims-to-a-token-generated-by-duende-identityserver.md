---
title: "How can I add custom claims to a token generated by Duende IdentityServer?"
date: "2024-12-23"
id: "how-can-i-add-custom-claims-to-a-token-generated-by-duende-identityserver"
---

,  I've spent a fair bit of time elbow-deep in IdentityServer, and dealing with custom claims is something I've frequently encountered – often in scenarios that, let's say, weren't textbook. Adding custom claims isn't just about adding extra data; it's about building a secure, flexible, and maintainable authentication and authorization system. We're talking about enriching tokens with application-specific or user-specific information that's critical for downstream services, and doing it correctly is paramount.

The core concept here revolves around the IdentityServer's extensibility points, primarily the `IProfileService` interface. This interface provides methods that are invoked during the token issuance process. It allows you to dynamically inject custom claims into access tokens and identity tokens based on the context, including the user's identity, the client requesting the token, and the scopes involved. Think of it as a hook into the token creation pipeline.

I remember a project where we had a multi-tenant application. Each tenant had a unique set of permissions and configurations. Instead of querying a separate database every time a downstream service needed to know what a user was allowed to do for a particular tenant, we opted to embed this information directly into the token as custom claims. This significantly improved performance and simplified the authorization logic in the consuming APIs.

Let’s get into the practical aspects and show you the process with some code examples. The key is to create a class that implements the `IProfileService` interface.

First, a basic implementation demonstrating how to add a custom claim:

```csharp
using IdentityServer4.Models;
using IdentityServer4.Services;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;

public class CustomProfileService : IProfileService
{
    public async Task GetProfileDataAsync(ProfileDataRequestContext context)
    {
        var user = context.Subject;

        if (user == null)
        {
            return;
        }

        var claims = new List<Claim>();

        // Example: Adding a custom claim with a fixed value.
        claims.Add(new Claim("custom_claim_example", "some_static_value"));

        // Example: Adding a claim based on user properties.
         // In a real scenario, you would fetch this user data from your user store
        var userId = user.FindFirst("sub")?.Value;
        if (userId == "someUserId")
        {
            claims.Add(new Claim("tenant_id", "tenant-a"));
            claims.Add(new Claim("application_role", "administrator"));
        }

        // Add claims to the context, which is used to create the token.
        context.IssuedClaims.AddRange(claims);
    }

    public async Task IsActiveAsync(IsActiveContext context)
    {
        // In a real scenario, you would check if the user is still active.
        // For this example we will set them to active, you might want to use real user data from storage here.
         context.IsActive = true;
    }
}
```

In this basic implementation, we add a static custom claim `custom_claim_example` and a `tenant_id`, and `application_role` based on the user's `sub` claim (Subject Identifier). Realistically, you would pull user information from your user store or database to add dynamic claims, as I did with our multi-tenant application.

Next, let’s see a slightly more involved example where we add claims based on requested scopes:

```csharp
using IdentityServer4.Models;
using IdentityServer4.Services;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;

public class ScopeBasedProfileService : IProfileService
{
    public async Task GetProfileDataAsync(ProfileDataRequestContext context)
    {
        var user = context.Subject;

        if (user == null)
        {
            return;
        }

        var claims = new List<Claim>();

        // Adding claims based on specific scopes requested
        if (context.RequestedScopes.Contains("scope_tenant_management"))
        {
             // Pretend we fetch tenant data based on the user and add tenant-specific claims.
            claims.Add(new Claim("manage_tenant", "true"));
            claims.Add(new Claim("allowed_actions", "create, read, update, delete"));
        }


       if (context.RequestedScopes.Contains("scope_user_read"))
        {
            // Pretend we fetch user specific data for this scope
            claims.Add(new Claim("user_profile_read", "true"));
        }

        // Add claims to the context
         context.IssuedClaims.AddRange(claims);
    }

   public async Task IsActiveAsync(IsActiveContext context)
    {
       // In a real scenario, you would check if the user is still active.
        // For this example we will set them to active, you might want to use real user data from storage here.
         context.IsActive = true;
    }
}
```

Here, the claims added are dependent on the scopes requested. If the client requests the `scope_tenant_management` scope, we add claims related to tenant management, and if `scope_user_read` is requested, we add user read claims, allowing finer control over what data is included based on the authorization request.

Finally, let’s demonstrate how to add claims when you have more complex logic for custom claims:

```csharp
using IdentityServer4.Models;
using IdentityServer4.Services;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;

public class ComplexClaimsProfileService : IProfileService
{
    private readonly ICustomUserStore _userStore;

    public ComplexClaimsProfileService(ICustomUserStore userStore)
    {
       _userStore = userStore ?? throw new ArgumentNullException(nameof(userStore));
    }


    public async Task GetProfileDataAsync(ProfileDataRequestContext context)
    {
       var user = context.Subject;

       if (user == null)
       {
           return;
       }

        var claims = new List<Claim>();

        //Fetch user from custom store.
         var userDetails = await _userStore.GetUserByIdAsync(user.FindFirst("sub")?.Value);


        if (userDetails != null)
        {
            // Example: Adding claims based on fetched user information.
            claims.Add(new Claim("user_given_name", userDetails.GivenName));
            claims.Add(new Claim("user_family_name", userDetails.FamilyName));
            claims.Add(new Claim("user_email", userDetails.Email));

           // Example: Adding claims from additional user information
           var roles = await _userStore.GetUserRolesAsync(userDetails.Id);
           foreach (var role in roles)
            {
                claims.Add(new Claim("role", role));
           }
       }

       if (context.RequestedScopes.Contains("my_api"))
        {
            claims.Add(new Claim("is_api_user", "true"));
        }

        context.IssuedClaims.AddRange(claims);
   }

   public async Task IsActiveAsync(IsActiveContext context)
    {
       // In a real scenario, you would check if the user is still active.
        // For this example we will set them to active, you might want to use real user data from storage here.
        context.IsActive = true;
    }
}

// Example custom user store interface
public interface ICustomUserStore
{
    Task<CustomUserDetails> GetUserByIdAsync(string userId);
    Task<List<string>> GetUserRolesAsync(string userId);
}

// Example custom user details class
public class CustomUserDetails
{
    public string Id { get; set; }
    public string GivenName { get; set; }
    public string FamilyName { get; set; }
    public string Email { get; set; }
    // Add other properties as needed
}
```

This final example demonstrates injecting dependencies, such as the `ICustomUserStore`, to abstract away data access logic. Here, we pull user details and roles to add dynamic claims based on the current user. It also shows how to use additional services to add even more dynamic claims.

To use these custom `IProfileService` implementations, you'd need to register them in your IdentityServer's dependency injection container:

```csharp
services.AddIdentityServer()
    .AddDeveloperSigningCredential()
    .AddInMemoryClients(Config.Clients)
    .AddInMemoryApiScopes(Config.ApiScopes)
    .AddInMemoryIdentityResources(Config.IdentityResources)
    .AddTestUsers(Config.Users.ToList())
    .AddProfileService<CustomProfileService>(); // Or ScopeBasedProfileService, or ComplexClaimsProfileService
```

Remember, thoroughly testing these custom claims is vital. Use tools like JWT.io to inspect the generated tokens and ensure the claims are present and correctly formatted.

For further reading, I recommend reviewing the IdentityServer4 documentation, specifically the sections on `IProfileService` and token customization. Additionally, the book "Programming ASP.NET Core" by Dino Esposito and Andrea Saltarello offers an excellent overview of security concerns in ASP.NET Core and could be a great resource for understanding the context of IdentityServer. Also, the book "OAuth 2 in Action" by Justin Richer provides deeper understanding of the principles behind token management. The documentation for IdentityServer's GitHub repository is also a great place to review code samples. Understanding the OAuth 2.0 specification itself (RFC 6749) is incredibly important as well.

Custom claims are a powerful tool, but ensure you use them judiciously. Avoid embedding large data blobs directly in the tokens, and always prioritize using a unique and consistent claim key across your applications. Also be aware that claims should be the minimal set of information required to complete a specific authorization process for downstream systems. Be mindful of the size of the token since large tokens can result in performance issues. Using this approach properly can make your architecture more flexible, scalable, and secure. Good luck!
