---
title: "Why does Rails 6.1.5 upgrade break `will_paginate` queries in a 6.0.3.7 application?"
date: "2024-12-23"
id: "why-does-rails-615-upgrade-break-willpaginate-queries-in-a-6037-application"
---

Let's explore why upgrading from Rails 6.0.3.7 to 6.1.5 can fracture `will_paginate` functionality; it’s a scenario I've certainly encountered and debugged more times than I’d prefer. The issue stems primarily from significant changes in how Rails handles database queries, particularly concerning how it constructs and interprets abstract syntax trees (asts) for activerecord queries, alongside modifications to how pagination is internally managed. It's not a direct bug in `will_paginate` itself, but rather a consequence of its interaction with these architectural shifts in Rails.

My prior experience with a legacy e-commerce platform vividly illustrates this. We had a fairly complex model structure, heavily reliant on `will_paginate` for both admin and customer-facing interfaces. The upgrade, designed to take advantage of performance improvements in Rails 6.1.x, initially seemed smooth until we noticed that paginated results were either empty or completely off, sometimes returning the entire dataset despite a specified page number. This led us down the rabbit hole of activerecord internals, and here's what we discovered.

Before we dive into specifics, remember that `will_paginate` fundamentally works by modifying the active record query to limit the number of results returned and offset the retrieval based on the specified page. It does this by manipulating the sql string generated by activerecord. The key point is that how activerecord generates these SQL queries changed between versions 6.0.x and 6.1.x.

The core culprit isn't a single change but rather a set of them impacting ast generation and execution within activerecord, specifically related to how `where` clauses and limit/offset operations are handled. Rails 6.1.x introduced more refined and efficient methods for query generation, often leveraging optimized sql fragments, but sometimes these optimization patterns interacted unexpectedly with `will_paginate`'s query manipulation. The problem mainly arose when using joins, complex conditions, or custom scopes, because those often generated sql that `will_paginate` was not expecting.

To further elaborate, here’s a simplified breakdown of what’s happening:

1.  **AST Changes:** Rails 6.1 introduced more robust ast processing. The way activerecord builds and manipulates the underlying data structure representing your query changed, leading to differences in the final generated SQL. The ast now can hold more metadata about query and is optimized in a more intelligent manner.

2.  **`limit` and `offset` Handling:** In Rails 6.0, the `limit` and `offset` clauses for pagination were applied in a way that `will_paginate` had been designed to work with. However, with the improvements to how `limit` and `offset` are calculated in 6.1.x, especially when using complicated joins or subqueries, the positions of those clauses in the final SQL generated changed from what `will_paginate` was designed to handle.

3.  **Query Scope Modification:** `will_paginate` operates by intercepting the active record query and adding the limit and offset constraints. With changes in AST, how active record renders it’s scope as sql changed and sometimes `will_paginate` would add those constraints in an incorrect order.

Now, let's look at code snippets to illustrate these issues and potential solutions.

**Snippet 1: Basic pagination with a `where` clause (May still work, but shows the structure)**

In Rails 6.0, this type of query would often translate to a specific pattern of sql, while in 6.1.5 this pattern could change due to the AST changes. This snippet demonstrates how `will_paginate` gets the current page and how we set the number of records per page.

```ruby
  def index
    @articles = Article.where(published: true).paginate(page: params[:page], per_page: 10)
  end

  #inside view
  <%= will_paginate @articles %>
```

This basic example could still work correctly, but it's crucial to understand the underlying mechanics, particularly if your model’s query generation is more complex. The core issues emerge when the sql gets more complicated.

**Snippet 2: Pagination with complex joins and a custom scope (Likely to fail)**

Here's where problems start to manifest:

```ruby
  # In Article model
  scope :with_author_and_category, -> {
    joins(:author, :category).where("authors.active = ? and categories.type = ?", true, "article")
  }

  def index
    @articles = Article.with_author_and_category.paginate(page: params[:page], per_page: 10)
  end

  #inside view
  <%= will_paginate @articles %>
```

In this scenario, after upgrading to Rails 6.1.5, the database might have returned either no results or incorrect pagination. `will_paginate`’s logic for appending limit and offset would have broken down because activerecord now renders complex queries like this in a different way. The sql generation differs in how it places the limit and offset.

**Snippet 3: Fixing the issue - A potential workaround (Not ideal but illustrates potential approach)**

The most robust fix isn't directly modifying `will_paginate` (which, while possible, is often a rabbit hole), but instead, adapting your query to work with Rails 6.1.x's new structure and, if necessary, using a custom pagination solution. A potential workaround, although not the most performant, involves using the `page` method in conjunction with the query itself to ensure the logic is in the correct order.

```ruby
  # inside index action
   articles = Article.with_author_and_category
   @articles = articles.limit(10).offset((params[:page].to_i - 1)*10) # use manual calculation.
   @total_count = articles.count

  #inside view
  <%= render partial: "pagination", locals: { current_page: params[:page].to_i, total_count: @total_count, per_page: 10 } %>
```

This example demonstrates how to perform pagination manually. It bypasses `will_paginate` and calculates the offset and limit on its own, working directly with active record. The pagination partial view would handle the pagination links. The key takeaway is to not rely solely on the blackbox approach of `will_paginate`, and manually handle pagination or explore another pagination library that is built for rails 6.1.

**Recommended Resources:**

Instead of directly linking, I’d strongly suggest delving into these resources:

1.  **“The Rails 6.1 Release Notes”**: Read this document thoroughly as it outlines the changes to activerecord.

2.  **"Agile Web Development with Rails 6" by Sam Ruby et al.** (Or the latest edition): This provides in-depth insights into activerecord and how queries are generated. It's a good investment for any rails developer to understand the internal plumbing.

3.  **"Database Internals: A Deep Dive into How Storage Engines Work" by Alex Petrov**: A much more generic resource but essential for understanding underlying sql and indexing strategies. It's useful to understand how databases handle queries and how changes in query generation can impact performance.

4.  **Active Record Documentation**: Always a good starting point. Specifically look at the documentation changes for Rails 6.1.x pertaining to the querying interface.

Ultimately, the issue with `will_paginate` breaking after a Rails upgrade highlights the importance of understanding the subtle architectural changes within a framework. While libraries like `will_paginate` can abstract away complexity, relying solely on them without fully grasping how the underlying system has changed is risky. If you are encountering issues with this package, your best option is to either upgrade to a more modern pagination approach, like `kaminari`, or to manually manage your pagination as shown above. This situation requires a combination of meticulous debugging and an in-depth understanding of active record's query generation patterns.
