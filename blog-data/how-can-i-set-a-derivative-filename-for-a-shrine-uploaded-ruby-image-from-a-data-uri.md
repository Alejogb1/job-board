---
title: "How can I set a derivative filename for a Shrine-uploaded Ruby image from a data URI?"
date: "2024-12-23"
id: "how-can-i-set-a-derivative-filename-for-a-shrine-uploaded-ruby-image-from-a-data-uri"
---

,  It's a common enough scenario, especially when dealing with modern frontends that leverage data uris for image previews before final submission. I remember back in my days working on that e-commerce platform, we had a similar issue where we were processing user-uploaded product images, including thumbnails generated server-side. The default filename handling from Shrine wasn't cutting it; we needed more control.

The core problem here revolves around the fact that a data uri, by its nature, doesn’t inherently contain filename information. Shrine, when presented with a data uri, has no way of deriving a filename unless explicitly told to do so. The default behaviour generally results in some kind of generated, often less-than-ideal, filename. What we need to do is intercept the upload process and provide a suitable filename when a data uri is the source.

The challenge, then, is two-fold: we need to identify when a data uri is being uploaded and then, more importantly, construct a reasonable filename that aligns with the image processing pipeline. We can accomplish this through Shrine's built-in mechanisms for attachment definition and processing, specifically using custom uploaders.

Let's break this down into actionable steps. First, we need a custom uploader. We can define it something like the snippet below, making use of Shrine's `Attacher` module to extend the functionality of the default uploader:

```ruby
class ImageUploader < Shrine
  Attacher.module do
    def assign(value, **options)
      if value.is_a?(String) && value.start_with?('data:')
        # handle data uri.  Extract mime type and generate a filename.
        mime_type = value[/^data:(.*?);/, 1]
        extension = mime_type.split('/').last if mime_type
        filename = SecureRandom.uuid + (extension ? ".#{extension}" : "")

        # create an in-memory file to pass to shrine
        io = StringIO.new(Base64.decode64(value.split(',').last))
        io.original_filename = filename
        io.content_type = mime_type if mime_type

        super(io, **options)
      else
        super(value, **options) #handle non-data uri requests as usual.
      end
    end
  end
end
```
In this code snippet, the `assign` method is overridden to intercept the upload process. We examine the value to ascertain if it is a data uri using the `start_with?('data:')` check. If it is, we extract the mime-type using regex, derive the extension, generate a random uuid, create an `StringIO` object from the base64 data, and finally pass it to the original `assign` method. The `super(io, **options)` call then correctly uploads this file using the new filename. If the value isn’t a data uri, we fall back to the original behaviour using `super(value, **options)`.

Now, let's take this a step further. We might want to generate different filenames for derivatives. Imagine we have a `thumbnail` and `large` derivative being generated by Shrine. We can extend our custom uploader to account for this:

```ruby
class ImageUploader < Shrine
  Attacher.module do
    def generate_location(io, derivative: nil, **options)
     
      if io.respond_to?(:original_filename) && io.original_filename
        base_name = File.basename(io.original_filename, File.extname(io.original_filename))
        extension = File.extname(io.original_filename).sub(/^\./, '')
        
        if derivative
           "uploads/#{base_name}-#{derivative}-#{SecureRandom.uuid}.#{extension}"
        else
           "uploads/#{base_name}-#{SecureRandom.uuid}.#{extension}"
        end
      else
        super
      end
    end

    def assign(value, **options)
        if value.is_a?(String) && value.start_with?('data:')
            mime_type = value[/^data:(.*?);/, 1]
            extension = mime_type.split('/').last if mime_type
            filename = SecureRandom.uuid + (extension ? ".#{extension}" : "")

            io = StringIO.new(Base64.decode64(value.split(',').last))
            io.original_filename = filename
            io.content_type = mime_type if mime_type

            super(io, **options)
        else
            super(value, **options)
        end
    end
  end
end
```

In this refined version, I have added a `generate_location` method to our uploader. This method, which Shrine calls when it needs a storage location (including filename), checks for the `original_filename` attribute which we had set earlier. If it exists, it extracts the base name, and appends the derivative name as part of the filename. If not derivative is specified, or if original filename is not present, it falls back to Shrine's default behavior with the `super` method. Notice how the `assign` method implementation remains the same, effectively setting the `original_filename` on the `io` object, which `generate_location` then makes use of. This approach allows us to create descriptive filenames for each derivative.

Finally, we can expand our approach to handle files uploaded directly via multipart-form. We should consider the case where a filename is provided by the client within the multipart form:

```ruby
class ImageUploader < Shrine
    Attacher.module do
        def generate_location(io, derivative: nil, **options)

            if io.respond_to?(:original_filename) && io.original_filename
                base_name = File.basename(io.original_filename, File.extname(io.original_filename))
                extension = File.extname(io.original_filename).sub(/^\./, '')

                if derivative
                    "uploads/#{base_name}-#{derivative}-#{SecureRandom.uuid}.#{extension}"
                else
                    "uploads/#{base_name}-#{SecureRandom.uuid}.#{extension}"
                end
            else
                super
            end
        end
        
        def assign(value, **options)
            if value.is_a?(String) && value.start_with?('data:')
                mime_type = value[/^data:(.*?);/, 1]
                extension = mime_type.split('/').last if mime_type
                filename = SecureRandom.uuid + (extension ? ".#{extension}" : "")
    
                io = StringIO.new(Base64.decode64(value.split(',').last))
                io.original_filename = filename
                io.content_type = mime_type if mime_type

                super(io, **options)
           elsif value.is_a?(ActionDispatch::Http::UploadedFile) || value.is_a?(Rack::Test::UploadedFile)
               
              io = value
              io.original_filename = value.original_filename #ensure filename is set.
                
              super(io, **options)
           else
                super(value, **options)
            end
        end
    end
end
```
Here I've added another branch within the `assign` method using `is_a?(ActionDispatch::Http::UploadedFile) || value.is_a?(Rack::Test::UploadedFile)` to check for the multipart-form uploaded files. I then ensure the `original_filename` is set, so the `generate_location` can leverage it. This covers more upload scenarios.

To truly grasp the intricacies of Shrine's internal workings, I highly recommend diving into the source code itself (available on GitHub). Further, the official Shrine documentation is exceptionally thorough and should be your primary reference when working with this library. Additionally, reading *Ruby on Rails Tutorial* by Michael Hartl can improve your understanding of Rails and how it interacts with libraries such as Shrine. For a more general understanding of file uploading strategies and file processing in web applications, consider reading sections on file handling from *Web Application Architecture* by Leon Anavi and Jason Yip.

Implementing a system like this adds both flexibility and robustness to your file upload pipeline. The ability to handle data uris and provide more descriptive filenames significantly reduces the headaches that can arise when dealing with file uploads, and the ability to extend it further through derivative location generation adds an extra layer of control. The experience of refactoring a chaotic upload process with something like this taught me a valuable lesson in the importance of granular control over every aspect of an application's functionality.
