---
title: "How to expire JWT tokens after 30 minutes of inactivity using Rails Devise-JWT?"
date: "2024-12-23"
id: "how-to-expire-jwt-tokens-after-30-minutes-of-inactivity-using-rails-devise-jwt"
---

Alright, let's tackle this one. It's a scenario I’ve encountered more times than I care to remember, particularly in projects where robust security and a good user experience need to co-exist peacefully. The goal, as I understand it, is to invalidate jwt tokens generated by devise-jwt after a period of 30 minutes of inactivity, not necessarily 30 minutes from when the token was originally issued. It’s a nuance that can significantly affect the security profile of your application and user satisfaction. The standard expiry of a JWT, based on its 'exp' claim, is insufficient for this use case. We need something a bit more dynamic.

First off, it's crucial to understand that the jwt itself, once issued, is stateless. That means we can't simply reach in and say “poof, be gone” after 30 minutes. Instead, the expiry must be tied to the user’s activity within the application. This typically involves a combination of strategies which I've used effectively on multiple projects.

What we’ll aim for is this: every interaction with the server (via a route that’s protected by devise-jwt), will reset a user's inactivity timer. If the user doesn’t interact for 30 minutes, then when they next try to use their token, it will be considered expired.

The first step involves storing a last_activity timestamp associated with the user. This is something you'll need to add to your users table if you don't already have something analogous. A simple `last_activity_at` column, as a timestamp, is perfectly acceptable.

The core logic lives in your token decoding process. We need to hook into devise-jwt to check the `last_activity_at` field *before* we consider the token valid. This involves overriding the token decoding or verification process, where we will perform this additional check. Specifically, the `jwt_payload` method in your devise model is a great place to inject this logic. Let’s see a code snippet for that:

```ruby
# app/models/user.rb
class User < ApplicationRecord
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtDenylist

  def jwt_payload
    super.merge({
      'last_activity_at' => last_activity_at.to_i
    })
  end

  def self.from_jwt_payload(payload)
    user = super(payload)
    return unless user

    last_activity_at = payload['last_activity_at']
    return user unless last_activity_at.present?

    if Time.at(last_activity_at) < 30.minutes.ago
        nil
    else
      user.update(last_activity_at: Time.now)
      user
    end
  end
end
```

Here's what's happening: The `jwt_payload` method is customized to inject our `last_activity_at` timestamp into the payload. This makes it available when the token is decoded. The `from_jwt_payload` method is our hook into the token verification. Before returning the user, we first compare the timestamp in the payload against the current time. If it’s older than 30 minutes, we return `nil`, effectively invalidating the token. Otherwise, if valid, we update `last_activity_at` to the current timestamp for the next cycle, ensuring the inactivity counter is refreshed.

Secondly, we need to ensure `last_activity_at` is updated on each valid token usage. The above code snippet takes care of this, but a different implementation might require additional considerations.

Thirdly, since devise-jwt utilizes a revocation strategy, `JwtDenylist` in this case, we need to address this aspect when invalidating tokens due to inactivity. If an inactivity-expired token is encountered, it should *not* be added to the denylist. This can be achieved by modifying how devise-jwt revocation works.

```ruby
# app/models/jwt_denylist.rb
class JwtDenylist < ApplicationRecord
  include Devise::JWT::RevocationStrategies::Denylist

  self.table_name = 'jwt_denylists'

  def self.jwt_revoked?(payload, user)
      super && (payload['last_activity_at'].nil? || Time.at(payload['last_activity_at']) > 30.minutes.ago)
  end

  def self.revoke_jwt(payload, user)
      create!(jti: payload['jti'])
  end
end
```

Here, we’ve overridden `jwt_revoked?` to *not* consider a token revoked based on the denylist if it’s considered stale due to inactivity. However, when a user explicitly logs out, a token should be revoked via the denylist, which will be handled by `super`. This avoids polluting your denylist with automatically invalidated tokens. This strategy makes sure denylist only contains explicitly invalidated tokens, not those expired by inactivity. The `revoke_jwt` is kept to default so the logout functionality is intact.

Finally, we also need to consider how you might invalidate all existing tokens if, say, you've updated security parameters or need to force all sessions to reset. This will depend on your chosen `jwt_revocation_strategy`. For `JwtDenylist`, clearing the table will suffice, and it is the reason we made sure that inactivity expired tokens do not reach denylist.

Now, a few points about this approach:

*   **Scalability:** This solution adds an extra query per request to verify the timestamp and potentially update the user record. It's worth considering the impact of this operation on your database, particularly under heavy load. Caching strategies may be beneficial if you need to optimize this further, but the default approach tends to work well for typical applications.
*   **Time Synchronization:** This implementation assumes good time synchronization between your server and database. If there are significant discrepancies, you could experience inconsistencies. Ensure your servers have accurate time settings using ntp.
*   **Edge Cases:**  Be mindful of edge cases, such as token reuse from previous instances. The `jti` claim, included by default with devise-jwt and used in the revocation strategy, helps to prevent replay attacks, but it is wise to thoroughly test edge cases as they arise in your application.

For delving deeper into the nuances of jwt security and strategies such as these, I highly recommend studying *RFC 7519: JSON Web Token (JWT)* which is the foundational standard. Additionally, for insights on authentication and authorization in web applications in general, *Web Security for Developers* by Bryan Sullivan and Vincent Liu provides a practical perspective.  Also, reading about 'Token-Based Authentication' on resources like Auth0’s blog or documentation can give a broader perspective.

This is the practical approach I've found works best in ensuring that jwt tokens expire based on user inactivity. It is important to note that security is not a one-time configuration, but a continuous process. Therefore, constantly reviewing and testing your security setups is crucial to the health of your application. I hope this detailed explanation helps you implement this effectively.
