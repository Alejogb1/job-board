---
title: "Why is FFmpeg's concat demuxer producing corrupted video segments?"
date: "2024-12-23"
id: "why-is-ffmpegs-concat-demuxer-producing-corrupted-video-segments"
---

Right, let’s dive into this. The issue of ffmpeg's concat demuxer spitting out corrupted video segments is something I’ve definitely encountered in the trenches, and it’s usually not a straightforward problem to diagnose. It’s less about inherent flaws in ffmpeg itself and more about subtle mismatches in how source files are structured and how the demuxer is interpreting them. The core challenge stems from the fact that the concat demuxer essentially treats a list of files as if they were a single continuous stream. This works brilliantly when everything is perfectly aligned, but inconsistencies quickly lead to playback issues.

From my experience, problems most often arise from three primary areas: differences in stream parameters, especially frame rates or codec profiles; inaccurate timecode information, which affects how frames are sequenced and presented; and issues with containers themselves not being properly aligned for seamless concatenation. When the demuxer encounters these inconsistencies, it can't properly stitch the video and audio data, leading to corruption, glitches, or even complete playback failure. Let’s explore each of these areas with some practical examples and solutions.

**1. Inconsistent Stream Parameters:**

The first and perhaps most common culprit is inconsistent stream parameters between the files you’re trying to concatenate. For instance, if you have two video files, one encoded at 30 frames per second (fps) and another at 60 fps, the concat demuxer will struggle. It expects a consistent stream throughout, and these shifts confuse the playback mechanism. Similarly, different codec profiles, even within the same codec, can cause problems because they may have varying compression settings, and the demuxer interprets these settings as a single, continuous, consistent stream.

Imagine a scenario: I was once working on a project where we needed to assemble several short video clips captured with varying settings on mobile devices. I encountered these exact issues. Some devices captured in 30 fps, some in 60, and even within the same fps, they'd have very slightly different bitrates, which, though usually invisible during playback of the singular files, can cause issues for the concat process. The result was a corrupted output, flickering, and audio misalignment.

To avoid this, you need to ensure that all video files have identical stream parameters. This is achieved by re-encoding the clips before concatenation using ffmpeg to match settings. Below is an example that enforces a single stream configuration across files, useful before running your concat sequence. This snippet re-encodes video to 30 fps with a consistent codec:

```bash
#!/bin/bash

input_dir="input_videos"
output_dir="reencoded_videos"
mkdir -p "$output_dir"

for file in "$input_dir"/*.mp4; do
    filename=$(basename "$file" .mp4)
    output_file="$output_dir/${filename}_reencoded.mp4"
    ffmpeg -i "$file" \
    -c:v libx264 -pix_fmt yuv420p -r 30 -preset medium -crf 23 -c:a aac -b:a 192k \
     "$output_file"
done

# After re-encoding, then proceed to concat
echo "Re-encoding complete. Now you can use the concat demuxer on '$output_dir'"
```

This script iterates through a directory, re-encodes each .mp4 file to a consistent set of parameters, and places the output in another directory. Here, `-c:v libx264` specifies the video codec, `-pix_fmt yuv420p` sets the pixel format, `-r 30` sets the frame rate to 30 fps, `-preset medium` and `-crf 23` handle video quality settings, and finally `-c:a aac` and `-b:a 192k` address the audio side. After the re-encoding process, the now-consistent clips should work flawlessly with the concat demuxer.

**2. Inaccurate Timecodes:**

The second common issue is related to timecode. Some video files, particularly those generated by editing software, may not have perfectly sequential timecodes. The concat demuxer relies on these timecodes to sequence the frames correctly. If the timecodes jump unexpectedly, the demuxer can lose its position and produce corrupted video segments or jumpy playback.

A frequent situation is clips with timecode starting at '0', which can cause problems when concatenated. When using the concat demuxer, it expects timecodes to continue in sequence, not starting afresh. This is a relatively subtle issue which took me some time to debug back when I was less experienced with ffmpeg.

To address this, ensure that the video files either have continuous timecodes or re-index the files. Below is a more specific script using the `setpts` filter, demonstrating how to fix timecode problems:

```bash
#!/bin/bash
input_dir="reencoded_videos"
output_dir="adjusted_timecode_videos"
mkdir -p "$output_dir"

for file in "$input_dir"/*.mp4; do
    filename=$(basename "$file" .mp4)
    output_file="$output_dir/${filename}_timecodefixed.mp4"

    ffmpeg -i "$file" \
        -vf "setpts=PTS-STARTPTS" \
        -c:v copy -c:a copy "$output_file"
done

echo "Timecode fixed. Now files are suitable for concat."
```

In this script, `-vf "setpts=PTS-STARTPTS"` is the key element. It adjusts the presentation time stamps (PTS) of each frame to start at '0'. While it doesn't directly re-write the original timecode, it makes timecode consistent for concatenation. Using `-c:v copy -c:a copy` ensures video and audio are stream copied instead of re-encoded again. These changes essentially ensure continuous and logical playback once concatenated.

**3. Container Inconsistencies**

Lastly, minor variations in the containers can cause problems. Although most modern containers such as mp4 or mov are well-defined, certain configurations or metadata differences can still lead to parsing errors. In particular, this may relate to how the header or 'moov' atom is structured.

While re-encoding or re-muxing the files can often alleviate container-related issues, I've found cases where the specific muxing settings were the culprit. In one particular case, we were combining MPEG-TS segments and had to pay close attention to the muxing for concatenation, otherwise, they resulted in artifacts.

Here is a script that illustrates re-muxing to a consistent container and codec:

```bash
#!/bin/bash
input_dir="adjusted_timecode_videos"
output_dir="remuxed_videos"
mkdir -p "$output_dir"

for file in "$input_dir"/*.mp4; do
  filename=$(basename "$file" .mp4)
  output_file="$output_dir/${filename}_remuxed.mp4"

  ffmpeg -i "$file" -c copy -map 0 "$output_file"
done

echo "Remuxing done. These files are ready for concatenation."
```

The command `-c copy -map 0` copies all the video and audio streams without any modification. This operation essentially rewrites the container while keeping the media content untouched and helps with situations where the container structure can pose issues for concat processes. This operation will ensure a consistent container that's less prone to incompatibilities during the concatenation step.

**Recommended Resources:**

For further reading, I’d strongly recommend digging into the following: the ffmpeg documentation, of course, is crucial, specifically the demuxing and filtering sections. Look into the MPEG-4 (ISO/IEC 14496-14) standard for a deep dive into the structure of mp4 containers. Additionally, the book *FFmpeg Basics* by Jim Delany provides a great practical overview, including its internals, and is an excellent companion for working with ffmpeg. Finally, *Video Demystified* by Keith Jack provides detailed information on video encoding and the various codecs. These should give you a solid footing in resolving similar issues.

In summary, when facing corrupted output from ffmpeg's concat demuxer, investigate differences in stream parameters, timecode issues, and variations in container structures. Addressing these areas with the examples I've provided should significantly improve your ability to produce clean, smoothly concatenated video segments. Remember, careful preparation before concatenation is often the most important step.
