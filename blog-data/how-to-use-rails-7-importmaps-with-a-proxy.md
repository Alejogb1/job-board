---
title: "How to use rails 7 importmaps with a proxy?"
date: "2024-12-15"
id: "how-to-use-rails-7-importmaps-with-a-proxy"
---

alright, let's talk importmaps and proxies in rails 7. it's a setup i've definitely banged my head against a few times, so i can share what i've learned, and some pitfalls i encountered.

first off, importmaps are rails' way of handling javascript dependencies without needing node. it's all about defining which modules to load directly in the browser using es modules, instead of bundling everything with webpack or a similar tool. this keeps things simple in many cases, but it introduces a wrinkle when you're working behind a proxy server, which a lot of us are, especially in enterprise environments.

the core problem is that the importmap generated by rails points to resources on the open internet (like jsdelivr cdn), which your browser can't access directly when behind a proxy. the browser needs to go through the proxy, but it’s completely unaware of that extra step when following the importmap's urls. this basically leads to lots of "failed to fetch" errors in the console.

here's the core of the issue: your `config/importmap.rb` file defines the locations for your javascript dependencies. let's see a typical example:

```ruby
pin "application", preload: true
pin "@hotwired/turbo", to: "turbo.min.js", preload: true
pin "@hotwired/stimulus", to: "stimulus.min.js", preload: true
pin "@rails/actioncable", to: "actioncable.esm.js", preload: true
```

this instructs rails to generate a map of these entries that the browser uses. when the browser sees something like `import { Turbo } from "@hotwired/turbo"`, it looks in the map for where to fetch `@hotwired/turbo` and goes straight to the url. in a normal setup, this works great. behind a proxy server though, this is a no-go.

one way i tackled this in the past, and probably the most common solution, is to mirror the needed javascript assets somewhere your proxy can access. for example, you could set up a simple web server that hosts these libraries. this is not the cleanest approach but is straightforward and usually works.

the proxy setup is not actually done in `importmap.rb`, but in your application server or system configuration itself.

let’s imagine you set up a web server under `http://my-local-js-mirror.lan/js/`. this mirror server serves the same files that you'd usually get from a cdn. for instance, `http://my-local-js-mirror.lan/js/turbo.min.js` would host the turbo.js file.

now, you can update your `config/importmap.rb` file. your `importmap.rb` should now look like this:

```ruby
pin "application", preload: true
pin "@hotwired/turbo", to: "http://my-local-js-mirror.lan/js/turbo.min.js", preload: true
pin "@hotwired/stimulus", to: "http://my-local-js-mirror.lan/js/stimulus.min.js", preload: true
pin "@rails/actioncable", to: "http://my-local-js-mirror.lan/js/actioncable.esm.js", preload: true
```

this tells rails to generate an import map that uses your local mirror server, avoiding the need to directly contact cdn. however, it's critical that you remember to host the actual files.

the downside of this is maintenance; you're now responsible for keeping these mirrored files up to date. when new versions come out, you have to manually update the mirror and your `importmap.rb` file accordingly. this quickly becomes cumbersome.

another, more advanced approach involves using a local npm registry in combination with a bundler that can export a set of esm files and setting up your own cdn. i once spent a solid week trying to solve this with npm, it was not ideal, but it worked at that time because it was the only way to achieve what i needed.

here's the gist of it. first, you’d have to use npm to install the needed packages locally.

```bash
npm install @hotwired/turbo @hotwired/stimulus @rails/actioncable
```

then, use a bundler like esbuild or rollup to produce es modules bundles, those that can be served from your custom cdn. you could use the example in the next example.

let's create a simple esbuild file called `esbuild.config.js`:

```javascript
const esbuild = require('esbuild');

esbuild.build({
  entryPoints: [
    'node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js',
    'node_modules/@hotwired/stimulus/dist/stimulus.js',
    'node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js'
    // add other packages as needed
  ],
  bundle: false,
  outdir: 'public/assets/js', // where your local cdn will be served
  format: 'esm',
  splitting: true,
  sourcemap: 'external',
  minify: false,
}).then(() => console.log('build finished'));
```
and then run with
```bash
node esbuild.config.js
```

this will produce javascript esm files that you can serve from your local cdn. after running that you need to modify your `importmap.rb` file as follows:

```ruby
pin "application", preload: true
pin "@hotwired/turbo", to: "/assets/js/turbo.es2017-esm.js", preload: true
pin "@hotwired/stimulus", to: "/assets/js/stimulus.js", preload: true
pin "@rails/actioncable", to: "/assets/js/actioncable.esm.js", preload: true
```

the important part is how you are serving the files. in the above example, i assumed you are serving the files using rails' public folder, but you could also use a dedicated web server.

a further step would be to use a local npm registry (like verdaccio) so you have all packages inside your network, making the whole process proxy proof. but that is already too much for the current topic, so let's leave that to another time.

i think the best way to think of this is that `importmap.rb` is not about "proxy settings" but rather it’s about where your application is sourcing javascript modules. the proxy itself has to be handled separately at the network level or via your web server config. this avoids making importmap into something it’s not designed to do. it’s a configuration tool for module loading and not a network tool per se.

as for resources, instead of links, i can recommend a few good books/papers. while there aren't books specific to rails importmaps and proxies, i found the "javascript modules: a deep dive" (i cannot recall the exact author, sorry, but it is a popular one) a very helpful read to fully understand module resolution, which forms the base of how importmaps function. also, for understanding the network side of things, look for any standard texts on web servers, reverse proxies, and especially on esm loading mechanisms from the browser perspective, a lot of them are available online.

one last thing i had a difficult time when starting with importmaps was with nested paths in the importmap. make sure to have the path correctly defined when pinning something, as this may cause some troubles, that you may think they are a proxy issue but are not (a lot of time was spent by me in this specific case, just to realize i had a typo in the importmap).

and, of course, remember to clear your browser cache after making changes, because browser caching is, as i like to say, *the friend that always forgets to update*. i hope this helps, and you will not spend as much time as i did on this.
