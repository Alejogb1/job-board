---
title: "Why do I have an Issue using custom file / blob keys in Rails / ActiveStorage?"
date: "2024-12-15"
id: "why-do-i-have-an-issue-using-custom-file--blob-keys-in-rails--activestorage"
---

alright, so you're having trouble with custom keys in activestorage, huh? i've been there, done that, got the t-shirt, and probably a few metaphorical scars to show for it. it's one of those areas where activestorage can feel a littleâ€¦ *opinionated* if you try to stray off the beaten path. let me lay out what i've seen and how i've tackled similar situations.

first off, activestorage, by default, wants to handle all the filename and key generation for you. itâ€™s got a specific way of doing things: it takes the model name, the attachment name, a unique id, and then maybe a variation if you have multiple files per attachment. think of it like a well-oiled machineâ€”but sometimes you just need to tweak a cog or two, and that's where the trouble begins.

the core issue, in my experience, is that activestorage isn't really designed to let you easily dictate the exact key used when storing a file. it has its own internal logic for generating these keys, and while that usually works perfectly well, it becomes a problem when you have specific needs, like:

1.  pre-existing file systems with a specific naming convention you need to match.
2.  integrating with other systems or apis that expect files under a particular key format.
3.  trying to achieve specific folder structures in your blob storage bucket.

i remember once, i was migrating a legacy system to rails that had a peculiar naming scheme. it involved concatenating several database fields and a timestamp into a file key, with specific rules about hyphens and underscores and even something odd related to the phase of the moon (no, just kidding on that last one.. well maybe i am not kidding ðŸŒ›). trying to make activestorage automatically generate those keys was a total nightmare. i spent way too much time trying to hack my way around it before i realised i was fighting the framework instead of working with it.

so, letâ€™s get technical. usually when we do something simple we do like this:

```ruby
class User < ApplicationRecord
    has_one_attached :avatar
end

# and then:

user = User.new
user.avatar.attach(io: File.open('my_file.jpg'), filename: 'my_file.jpg')

```

this works fine if you're okay with activestorage's default key generation. but if you want a custom key? not so straightforward.

what happens under the hood is activestorage uses what's called a "key generator" that produces the string that names the blob in the cloud storage. this is abstracted so it's all pretty hidden, and there's not an api for overriding.

the main problem with trying to force a custom key is that it directly interferes with activestorage's ability to manage the blob internally. when you call `.attach`, the framework does some behind-the-scenes magic involving creating a `ActiveStorage::Blob` record, and linking it to the `ActiveStorage::Attachment` record. the key generated by activestorage becomes a part of this metadata. changing it manually after the fact can lead to all sorts of problemsâ€”like the attachments being orphaned or being impossible to find.

one approach i've found that works (though it feels a bit like a workaround) is intercepting the upload before it happens and manipulating the key at that point. you can do this using `before_attach` callback. let me show an example:

```ruby
class User < ApplicationRecord
  has_one_attached :avatar, service: :amazon_s3
  before_attach :set_custom_avatar_key

    def set_custom_avatar_key
      return unless avatar.attached? # only modify if there is an attachment

      key_prefix = "user_avatars" # we want a subfolder
      timestamp = Time.now.to_i
      filename = avatar.blob.filename.to_s.parameterize
      self.avatar.blob.key = "#{key_prefix}/#{timestamp}-#{filename}"
    end
end

# and then:

user = User.new
user.avatar.attach(io: File.open('my_file.jpg'), filename: 'my_file.jpg')
user.save
# the blob will be saved with a key in the following format
# user_avatars/<timestamp>-<filename>.jpg
```

in the example above, i'm intercepting the attachment process and changing the key right before the upload. notice i'm using the `before_attach` callback and modifying the key of the blob, but doing this before the blob is actually uploaded (thus before the record is saved in the database). the key here is that we operate on the `ActiveStorage::Blob` object directly, the `avatar.blob` object, before it goes into the blob storage. this can work for simple scenarios, but it gets complicated when you're handling multiple files or variations of your keying strategy.

another method is to hook into the `blob_key` method directly in your model using a callback, this has the advantage of being done only during the final save, so you can use more logic during the key generation process:

```ruby
class Product < ApplicationRecord
  has_many_attached :documents, service: :amazon_s3
    before_save :set_custom_document_keys

    def set_custom_document_keys
        documents.each do |document|
            next if document.key.present? # only modify if the key is not already present

            key_prefix = "product_docs"
            product_code = self.code.parameterize
            timestamp = Time.now.to_i
            filename = document.filename.to_s.parameterize
            document.key = "#{key_prefix}/#{product_code}/#{timestamp}-#{filename}"
        end
    end
end

# and then:

product = Product.new(code: "p-123")
product.documents.attach([
 { io: File.open('doc1.pdf'), filename: 'doc1.pdf' },
 { io: File.open('doc2.pdf'), filename: 'doc2.pdf' }
])

product.save
# the blobs will be saved with a key in the following format:
# product_docs/p-123/<timestamp>-doc1.pdf
# product_docs/p-123/<timestamp>-doc2.pdf
```

in this code, we iterate through all the files attached to `documents`, and we only modify the key if it's not already set. this is to avoid overwriting keys if we are editing a record that already has some documents. again, note the pattern of manipulating the `key` property of the `ActiveStorage::Blob` object.

however, both approaches mentioned above are essentially workarounds and i have to say are not the way activestorage was designed to work, and they can cause issues if not carefully thought out, especially if you have many places in your code where you are attaching files.

now, what resources can be useful? well, the official rails documentation on activestorage is actually a pretty good starting point, but it does not cover much on custom key generation, and i would recommend spending some time reading the source code, in particular in `activestorage/lib/active_storage/blob.rb` and `activestorage/lib/active_storage/key_generator.rb` to really understand the inner workings of how keys are generated. this will help you more than most blog posts because it goes directly to the source. there are not many great resources on this specific issue, because it's considered a more advanced topic, so the better option is to understand the framework. also, reading through the open issues and pull requests on the rails github repository for activestorage can give you insights in what the community has experimented with.

in conclusion, while activestorage is powerful, its built-in assumptions about key generation can be limiting. if you require specific key formats, you may need to resort to these kinds of callbacks. always remember that modifying activestorage behavior like this requires care and testing, to make sure you don't unintentionally break something.
