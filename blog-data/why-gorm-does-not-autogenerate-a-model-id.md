---
title: "Why Gorm does not autogenerate a model ID?"
date: "2024-12-15"
id: "why-gorm-does-not-autogenerate-a-model-id"
---

alright, so you're asking why gorm, that go orm, doesn't just automatically create an id field for your models, kinda like some other orms do. i get where you're coming from, it feels like it should just happen, doesn't it? been there, spent hours banging my head against the wall trying to get things to just *work*.

let me give you a bit of my history with this particular gorm quirk. back in the day, probably around 2017, i was working on a small service that tracked user activity for a forum, a sort of very basic user analytics tool. i jumped right into gorm, thinking, "this'll be easy, orm, no need to write raw sql." i defined my models, things like `user`, `post`, `comment` and i naively expected gorm to automagically figure out that every model needs a unique id. well, it didn't. and of course the first time i tried to create an entry i got an error that made zero sense at the time. i spent a couple of hours in the gorm docs and even the gorm github issues, mostly lost. i felt like i was missing some fundamental piece of the puzzle, that i was doing something very basic wrong.

after those two hours of frustration i realized my error: i had not defined explicitly an id. the gorm model must explicitly define the primary key. now, this is not a bug or an oversight in gorm, it’s an intentional design decision. gorm is built around the philosophy of explicitness and control. it doesn’t try to guess what you want but gives you the tools to define it exactly.

think about it this way. if gorm auto-created an id field, it would have to make some assumptions: what type should it be? integer? uuid? how do you want the id to be generated? auto increment? generated by some uuid algorithm? what name you want it to have? `id` is pretty default but maybe you like `my_record_id` or similar. these choices might seem trivial but when it comes to serious projects they can have a deep impact on performance and the overall architecture of the system, this is why gorm gives you control of this aspect of the model.

here's a basic example, how i usually define my gorm models and you should too:

```go
package main

import (
	"gorm.io/gorm"
	"gorm.io/driver/sqlite"
)


type User struct {
	ID   uint   `gorm:"primaryKey;autoIncrement"`
	Name string
	Email string  `gorm:"unique"`
	Age  int
}

func main() {
	db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	db.AutoMigrate(&User{})
    
    user := User{Name: "john doe", Email: "john.doe@email.com", Age: 27}
    db.Create(&user)


    var foundUser User
    db.First(&foundUser, 1)
    println(foundUser.Name) // prints: john doe

}

```

in this code the `id` field is of type `uint` (unsigned integer). the gorm tag `gorm:"primaryKey;autoIncrement"` tells gorm this field is the primary key and should be automatically incremented.

if you prefer a uuid as primary key, you can do this:

```go
package main

import (
    "github.com/google/uuid"
    "gorm.io/gorm"
	"gorm.io/driver/sqlite"
)

type Product struct {
    ID   uuid.UUID `gorm:"type:uuid;primaryKey;default:gen_random_uuid()"`
    Name string
	Price float64
}


func main() {
    db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    if err != nil {
        panic("failed to connect database")
    }

    db.AutoMigrate(&Product{})

    product := Product{Name: "keyboard", Price: 89.99}
    db.Create(&product)

    var foundProduct Product
    db.First(&foundProduct, product.ID)
    println(foundProduct.Name) // prints: keyboard
}
```

here, the `id` field is of type `uuid.uuid`. the gorm tag `gorm:"type:uuid;primaryKey;default:gen_random_uuid()"` defines this as primary key of type uuid and sets a default value generated by the `gen_random_uuid()` function.

the reason why i prefer to use uuid is, they are less prone to cause a collision on different databases when migrating the system or the use of different services with the same model type.

and for those who like text ids, you can do it like this:

```go
package main

import (
	"gorm.io/gorm"
	"gorm.io/driver/sqlite"
    "math/rand"
    "time"
    "fmt"
)


type BlogPost struct {
	ID   string `gorm:"primaryKey;size:255"`
	Title string
	Content string
}

func generateRandomID() string {
    rand.Seed(time.Now().UnixNano())
    return fmt.Sprintf("%x", rand.Int63())[:8]
}

func main() {
	db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
	if err != nil {
		panic("failed to connect database")
	}

	db.AutoMigrate(&BlogPost{})
    
    blogPost := BlogPost{ID: generateRandomID() ,Title: "my first post", Content: "lorem ipsum dolor sit amet."}
    db.Create(&blogPost)

    var foundPost BlogPost
    db.First(&foundPost, blogPost.ID)
    println(foundPost.Title) // prints: my first post

}
```

in this last example, the id is a string with a size limit of 255 characters and a function `generateRandomID` generates a random hexadecimal id of 8 characters. note that with this method you should add logic to control if the generated id already exists in the database. you probably should use a uuid.

so, gorm doesn't autogenerate the id for you. why? because it’s designed to be flexible and explicit. it forces you to think about how you want your primary keys to be structured, which leads to better database design. it gives you more control and avoids magic that may be harder to debug or adjust later on. and let me tell you, after all the errors that i had before, i prefer it this way.

if you want to get a more in-depth understanding about this i recommend you to read the gorm official documentation, and if you want a broader picture of database modeling there is “database system concepts” by silberschatz, korth and sudarshan which covers various aspects of database design. for sql best practices, consider "sql for dummies" it may sound silly but it is a good intro for sql no matter your experience level. and also the book "effective sql" by john l. viescas is a great resource too.

as a side note, and since we are talking about this topic, why did the database server break up with the sql query? because they had too many relations.

anyways, hope this explanation helps you understand gorm a little better, keep coding!
