---
title: "Why Rails 7/Stimulus: Connect() fires twice but why can I only access values on its first firing?"
date: "2024-12-15"
id: "why-rails-7stimulus-connect-fires-twice-but-why-can-i-only-access-values-on-its-first-firing"
---

alright, so, you've stumbled upon one of those classic, "wait, what's *actually* going on here?" moments with rails 7 and stimulus, specifically regarding the `connect()` lifecycle callback. it's something i've definitely banged my head against a few times, so let me try to break down what's happening and why you're only seeing the values you expect on that first `connect()`.

let's unpack this. at its core, stimulus controllers are designed to react to changes in the dom. when a stimulus controller's element is added to the dom, or if the controller is connected to an existing element it triggers the `connect()` callback.  what seems like a simple hook can have some unexpected consequences if not well understood.

the issue of `connect()` firing twice is less about stimulus and more about how hotwire (specifically turbo) is playing with the dom. in a normal page load, the controller will be connected to the dom, and `connect()` fires once. that's straightforward. but when you use turbo, things get interesting. turbo's goal is to intercept navigation and form submissions and update the page by replacing *parts* of the dom, without doing a full page reload. this leads to the controller element being removed and added back which will result on two firings.

turbo performs the initial page load of course, where the stimulus controller is present. let's call this `connect()` firing the first `connect()`. now, upon a turbo driven navigation or a form submission, turbo will swap a specific part of the dom. during this turbo swap the original html element containing the stimulus controller gets removed before being replaced with the new server rendered html. stimulus detects that an html element with a controller is being added back, so it connects to the controller again causing the second `connect()` firing.

this second firing is where it gets confusing: your values from `data-attributes` might appear missing. why? because these attributes are tied to the *original* dom element. the second time connect() fires, stimulus will get values for the currently existing dom attributes. turbo swaps the original element, but this swap is not necessarily a direct attribute copy of the previous element, so, in case you are relying on values that are not populated, these values may be `null` or `undefined`, or anything else depending on how the html was generated by the server.

i've personally seen this several times when i was building an interactive form that needed to dynamically change parts of the dom and i was using the data attributes to store form values. for instance, i had a controller, something simple, to display or hide certain input fields based on an option selected.

```javascript
// example controller: my_form_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["conditionalField"];
  static values = {
    showField: Boolean,
  }

  connect() {
    console.log("connect() fired:", this.showFieldValue);
    if (this.showFieldValue) {
      this.conditionalFieldTarget.classList.remove('hidden');
    } else {
      this.conditionalFieldTarget.classList.add('hidden');
    }
  }
}

```
and i would have a server generated `html` snippet as follows:
```html
<!-- the initial server side rendered html -->
<div data-controller="my-form" data-my-form-show-field-value="true">
  <div data-my-form-target="conditionalField" >
    show me
  </div>
</div>
```
this would work when loading the page, but when turbo swapped this the `data-my-form-show-field-value="true"` would be lost, if i was not careful, the second `connect()` would have the value `false`, and would hide my field because the new value for the `data-my-form-show-field-value` would be not present in the server html. in those times, my console logs where all over the place, one `true` followed by another `false` and the field would simply disappear. it took me a few hours to realize that i was working on the wrong element.

so, how to handle it? well, here's a good rule of thumb: **don't assume that attributes remain static across turbo navigations**. think of the second `connect()` as a "fresh start". the state of the controller might have changed. stimulus is not a state management framework. you need to store data and logic on the server and re-render the correct controller on the server side. you need to ensure the server sends the correct html with the correct attributes.

here's another example: say you have an `html` element as follows:

```html
<div data-controller="example" data-example-count-value="5">
  <button data-action="click->example#increase">Increment</button>
  <span data-example-target="countDisplay">5</span>
</div>
```

and you wanted to build an increment controller to track how many times a button was clicked. here is an example:

```javascript
// example controller: example_controller.js
import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["countDisplay"]
  static values = {
    count: Number
  }

  connect() {
    console.log("Initial count:", this.countValue); // this logs the initial count value only on first connect()
    this.updateDisplay();
  }

  increase() {
    this.countValue++
    this.updateDisplay();
  }

  updateDisplay() {
    this.countDisplayTarget.textContent = this.countValue;
  }
}
```

as you could imagine after a turbo swap the `countValue` will be reset. even though i may have updated the value of `this.countValue`, the attribute will be reset to `5` on the second `connect()`.

the `connect` hook it is not supposed to store the state. it is the initial state of the component from the server. therefore, this should be handled on the server side, and it is the server side responsibility to return the correct html with the current state, otherwise all changes will be lost.

a common pattern i've adopted is to treat the `connect()` callback as an initialization step. it's where i read values from the data attributes *provided by the server*, set up event listeners, and perform any other initial setup that depends on the initial dom state. for persistent data, i'd use more robust techniques like persisting the data on the server. if i need more dynamic interactions (updating the counter) i'd have an api endpoint to receive the new `count` or to fetch the current count and return a new html fragment with the correct value.

here's a final example, illustrating an alternative to storing values directly on the data attributes. instead of passing the initial count with data attributes the server responds with the current value. on form submissions or links i make an api request which responds with the current value.
```html
<div data-controller="counter">
  <button data-action="click->counter#increase">Increment</button>
  <span data-counter-target="countDisplay"></span>
</div>
```
and the corresponding javascript controller
```javascript
// example controller: counter_controller.js
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  static targets = ["countDisplay"];

  connect() {
    this.fetchCounter();
  }

  increase() {
    fetch('/api/counter/increment', { method: 'POST' })
      .then(() => this.fetchCounter());
  }

  fetchCounter() {
    fetch('/api/counter')
      .then(response => response.json())
      .then(data => {
        this.countDisplayTarget.textContent = data.count;
      });
  }
}
```
in this case, the server will respond on the `/api/counter` with the current value. on the initial connect() a `fetchCounter` is performed. this same function is called again on the `increase` function after an api request. this will guarantee data integrity.

now, i know this all might seem like a bit of an edge case, but it’s one of those details that can really throw you for a loop if you’re not aware of how turbo interacts with stimulus. it really all comes down to understanding that turbo driven updates can effectively re-render controllers in place. i’ve seen this trip up so many developers including myself. it’s not a bug; it’s how it’s designed to work, and it makes sense when you understand it.

if you want to go deeper into this and other interesting stuff about hotwire, i’d recommend "hotwire: the complete guide to build modern web applications with rails" by gordon fulton it has a great chapter explaining this behavior. also the stimulus handbook by nathan heinrich is a great resource to learn stimulus. those are my go to resources, forget blog posts and the never ending "solution-find" cycle.

as a closing thought, i’d say: always make sure to understand that the initial html of the controller should be fully generated by the server with all its attributes; only use the `connect()` lifecycle method to grab the initial state of the element; use the data attributes as input to the controller, but never as state holders. also remember, that debugging with console logs can lead to incorrect conclusions sometimes, specially if you are tired (like when you are working late at night and suddenly feel the urgent need to go to sleep). i've been there. hopefully this clarifies a bit on why this is happening.
