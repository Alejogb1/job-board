---
title: "How to resolve ORA-00907: missing right parenthesis error in a Django Wagtail Oracle migration?"
date: "2025-01-30"
id: "how-to-resolve-ora-00907-missing-right-parenthesis-error"
---
The ORA-00907 error, "missing right parenthesis", when encountered during a Django Wagtail Oracle migration, typically points to malformed SQL generated by Django's migration framework, specifically when attempting to alter or create tables with complex schema definitions. The underlying cause often stems from the nuances in how Oracle handles certain data types, constraints, or default values compared to other database systems like PostgreSQL or SQLite, which are commonly used for initial Django development. Specifically, nested expressions or data type specifications within column definitions that are perfectly valid in other SQL dialects can trigger this error in Oracle if the syntax isn’t perfectly adhered to.

I’ve encountered this exact issue multiple times during the refactoring of legacy Wagtail projects where the initial database was often not Oracle. Let’s break down why this happens and how to resolve it using practical examples. Django, when creating migrations, relies on its ORM to translate Python models into SQL. While Django’s abstraction generally works well, differences in how databases handle features like `JSONField`, `TextField`, or even `ForeignKey` relationships can lead to syntax discrepancies and the dreaded ORA-00907.

Here’s a structured explanation: Oracle has stricter rules on nested functions and parentheses placement, especially within `CREATE TABLE` or `ALTER TABLE` statements. If you’re using custom database functions, or relying on Django's implicit translations for complex fields, the generated SQL can easily contain unbalanced parentheses. For example, consider a Django model with a `JSONField` and a default value that looks deceptively simple in Python but produces problematic SQL in Oracle. This is compounded by Wagtail, which has many complex models and relationships, leading to potentially lengthy and complex SQL migrations.

Here are three code examples illustrating how I resolved the issue previously, coupled with code commentary:

**Example 1: Handling Default JSON values**

Let's say you have a `Settings` model in your Wagtail app that utilizes a `JSONField`. The model might look something like this:

```python
# models.py
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page
from jsonfield import JSONField


class Settings(Page):
    template = 'app/settings_page.html'
    some_data = JSONField(default={'status': 'draft', 'visibility': 'private'})

    content_panels = Page.content_panels + [
        FieldPanel('some_data'),
    ]
```

When a migration is created based on this, Django might generate SQL that is not compatible with Oracle. The default value of the `JSONField` might be problematic if Django attempts to represent it directly as a string within the SQL. If, for instance, the generated SQL is similar to:

```sql
-- Potential problematic SQL, not actual output from django
CREATE TABLE "app_settings" (
  ...
  "some_data" VARCHAR2(4000) DEFAULT '{"status": "draft", "visibility": "private"}'
);

```
This string representation, while valid for some databases, can fail in Oracle with ORA-00907, potentially because of how Oracle parses the nested quotes or the implicit type conversion.

To resolve this, instead of a Python dictionary as a direct default value within the model, we must provide a callable. This will avoid Django's attempt to create a SQL default value that can generate the malformed SQL.

```python
# models.py, corrected
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page
from jsonfield import JSONField


def default_settings_data():
    return {'status': 'draft', 'visibility': 'private'}

class Settings(Page):
    template = 'app/settings_page.html'
    some_data = JSONField(default=default_settings_data)

    content_panels = Page.content_panels + [
        FieldPanel('some_data'),
    ]
```

Now, when Django creates the migration, it avoids including the default value directly within the `CREATE TABLE` statement in Oracle SQL, instead relying on application-level defaulting which is much safer.

**Example 2: Issues with TextFields and Long Strings**

Consider a model with a long text field, such as a `TextField` or even `CharField` that has a default value with long text.

```python
# models.py
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page


class ArticlePage(Page):
    template = 'app/article_page.html'
    long_description = models.TextField(default="This is a very long default text string that might cause problems, especially with how the database handles strings longer than a certain length. This example aims to demonstrate how long, fixed-length strings within migrations can trigger Oracle errors.")

    content_panels = Page.content_panels + [
        FieldPanel('long_description'),
    ]
```

If Django attempts to create a default constraint within the `CREATE TABLE` or `ALTER TABLE` using this value directly, Oracle may throw the error. This is compounded if the SQL generated by the migrations attempts to use a fixed-length data type (e.g. `VARCHAR2`) instead of something more suitable to long strings like a `CLOB` or similar. It’s crucial to let the application handle the default values, rather than the database.

The corrected model would omit the default, and rely on either an application-level default or explicit initialisation on record creation.

```python
# models.py, corrected
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page


class ArticlePage(Page):
    template = 'app/article_page.html'
    long_description = models.TextField() # Removed default value

    content_panels = Page.content_panels + [
        FieldPanel('long_description'),
    ]
```
This ensures that no default value is specified in the generated SQL, avoiding Oracle's stringent parser. The application code, or model class methods, will need to handle the initial setting of `long_description` values instead.

**Example 3: Correctly Using Foreign Keys with Deferrable Constraints**

ForeignKey fields with specific on-delete behaviours (eg. `CASCADE`, `SET_NULL`) are, in principle, straightforward, but I've seen them cause issues in Oracle when also configured with `deferrable` constraints. Django handles creating these constraints in its migrations, and these can often lead to the ORA-00907 error if not handled correctly.

Consider a model with a ForeignKey:

```python
# models.py
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page


class RelatedPage(models.Model):
    title = models.CharField(max_length=255)

class ParentPage(Page):
    template = 'app/parent_page.html'
    related_page = models.ForeignKey(
        RelatedPage,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='parent_pages',
        db_constraint=True,
        # This is where the problem may arise if Django's translation of this SQL isn't careful
        # db_constraints=True, deferrable=models.DEFERRED, initially=models.DEFERRED
    )

    content_panels = Page.content_panels + [
        FieldPanel('related_page'),
    ]

```
If you were to add `deferrable=models.DEFERRED, initially=models.DEFERRED`, Django would attempt to create `DEFERRABLE INITIALLY DEFERRED` constraints in the generated SQL. While seemingly straightforward, the precise syntax and Oracle's interpretations can be extremely sensitive. If the underlying Oracle driver or Django's migration SQL generation fails to conform to the specific syntax rules Oracle expects for deferred constraints (including correct parenthesis usage), you'll encounter this error. I recommend avoiding explicit deferred constraints in migrations unless absolutely essential, as their complexity often outweighs the performance or data consistency gains.

The fix for this is to remove the additional `deferrable` and `initially` keyword arguments:

```python
# models.py, corrected
from django.db import models
from wagtail.admin.panels import FieldPanel
from wagtail.models import Page

class RelatedPage(models.Model):
    title = models.CharField(max_length=255)


class ParentPage(Page):
    template = 'app/parent_page.html'
    related_page = models.ForeignKey(
        RelatedPage,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='parent_pages',
        db_constraint=True
    )

    content_panels = Page.content_panels + [
        FieldPanel('related_page'),
    ]
```

These are three common cases where I’ve seen this specific error in Wagtail Oracle environments. The overarching solution is to carefully review generated migrations and identify areas where Django might be attempting to perform complex SQL statements, especially related to defaults or complex constraints, and rework your Django model definitions to let the application, rather than database schema, handle them.

In terms of resources, I would recommend focusing on the following to understand this issue more thoroughly:

*   The Oracle Database SQL Language Reference documentation which outlines syntax nuances, particularly how to work with data types, default values, and constraints.
*   Django documentation relating to model fields, specifically covering `JSONField`, `TextField`, `ForeignKey`, and other fields that might create SQL that isn’t compatible with Oracle.
*   The Wagtail documentation that covers database migrations and recommendations for handling different types of fields in models to avoid issues with different databases.
*   PostgreSQL database documentation, as this is commonly the starting database for Wagtail development, and comparison of its SQL with Oracle. Examining the differences in how constraints and data types are managed will illuminate how to approach Oracle compatibility.

By reviewing these resources, and through careful examination of your generated migrations, you should be able to identify and resolve ORA-00907 errors effectively. The key is to be mindful of the differences between databases and adopt a conservative approach when using Django ORM features that can lead to complex or ill-formed SQL statements.
