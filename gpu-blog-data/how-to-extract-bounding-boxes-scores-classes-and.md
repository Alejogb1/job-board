---
title: "How to extract bounding boxes, scores, classes, and counts from YOLOv5?"
date: "2025-01-30"
id: "how-to-extract-bounding-boxes-scores-classes-and"
---
YOLOv5's output isn't directly formatted as a list of bounding boxes, scores, and classes.  Instead, it provides a tensor containing these data points encoded within its structure.  Understanding this encoding is crucial for successful extraction.  My experience working on object detection projects involving large-scale video processing has highlighted the importance of efficient post-processing for YOLOv5 outputs, especially when dealing with real-time applications.  The extraction process involves several steps, from tensor manipulation to data reformatting.

**1. Understanding the YOLOv5 Output Tensor:**

The core of the process lies in deciphering the output tensor generated by the YOLOv5 model. This tensor, typically of shape (1, num_detections, 6), holds the detection results.  Each row represents a single detection, and the six values within each row represent:  `x_center`, `y_center`, `width`, `height`, `confidence`, and `class_id`.  `x_center` and `y_center` represent the normalized coordinates of the bounding box's center, `width` and `height` represent the normalized width and height of the bounding box, `confidence` is the objectness score indicating the likelihood of a detection being an object, and `class_id` is the index of the detected class within the model's class definition list.  Note that these values are normalized to the input image dimensions.  For instance, a value of 0.5 for `x_center` indicates the center is located at the horizontal midpoint of the image.


**2.  Extraction Process and Code Examples:**

Extracting the relevant information requires careful tensor manipulation and potentially some NumPy operations.  I'll present three examples demonstrating different approaches and levels of sophistication, focusing on clarity and efficiency.

**Example 1: Basic Extraction using NumPy:**

This approach uses NumPy for direct tensor manipulation. It's straightforward but lacks error handling and sophisticated filtering.  I used this method extensively during initial prototyping stages of various YOLOv5-based systems.

```python
import torch
import numpy as np

# Assume 'output' is the YOLOv5 model output tensor
output = torch.randn(1, 10, 6)  # Example output tensor

# Convert to NumPy array for easier manipulation
output_np = output.cpu().numpy().squeeze() #squeeze removes the batch dimension if it's 1

# Extract relevant information
bboxes = output_np[:, :4]
scores = output_np[:, 4]
class_ids = output_np[:, 5].astype(int)

#Print results. Note: this assumes a known class list.  I'd normally store that separately.
print("Bounding Boxes:\n", bboxes)
print("\nScores:\n", scores)
print("\nClass IDs:\n", class_ids)

#Get number of detections
num_detections = len(scores)
print("\nNumber of Detections:", num_detections)
```

**Example 2:  Adding Confidence Thresholding:**

This example improves upon the basic extraction by introducing a confidence threshold. This filters out low-confidence detections, significantly reducing false positives.  I found this particularly beneficial when working with noisy datasets.

```python
import torch
import numpy as np

output = torch.randn(1, 10, 6) # Example output tensor
confidence_threshold = 0.5

output_np = output.cpu().numpy().squeeze()

# Apply confidence threshold
mask = output_np[:, 4] > confidence_threshold
bboxes = output_np[mask, :4]
scores = output_np[mask, 4]
class_ids = output_np[mask, 5].astype(int)

num_detections = len(scores)

print("Bounding Boxes:\n", bboxes)
print("\nScores:\n", scores)
print("\nClass IDs:\n", class_ids)
print("\nNumber of Detections:", num_detections)
```


**Example 3:  Denormalization and Class Label Assignment:**

This example goes a step further by denormalizing the bounding box coordinates and assigning class labels based on a predefined class list. This is a crucial step for visualization and downstream tasks.   This refined methodology was indispensable during the final stages of several of my projects, ensuring seamless integration with visualization libraries and other components.

```python
import torch
import numpy as np

output = torch.randn(1, 10, 6) #Example output tensor
confidence_threshold = 0.5
img_width = 640
img_height = 480
class_names = ["person", "car", "bicycle"] #Example class list

output_np = output.cpu().numpy().squeeze()

mask = output_np[:, 4] > confidence_threshold
bboxes = output_np[mask, :4]
scores = output_np[mask, 4]
class_ids = output_np[mask, 5].astype(int)

# Denormalize bounding boxes
bboxes[:, 0] = bboxes[:, 0] * img_width - bboxes[:, 2] / 2  #x_min
bboxes[:, 1] = bboxes[:, 1] * img_height - bboxes[:, 3] / 2 #y_min
bboxes[:, 2] = bboxes[:, 0] + bboxes[:, 2] #x_max
bboxes[:, 3] = bboxes[:, 1] + bboxes[:, 3] #y_max

# Assign class labels
class_labels = [class_names[i] for i in class_ids]

num_detections = len(scores)

print("Bounding Boxes (denormalized):\n", bboxes)
print("\nScores:\n", scores)
print("\nClass Labels:\n", class_labels)
print("\nNumber of Detections:", num_detections)

```

**3. Resource Recommendations:**

The official YOLOv5 documentation,  a comprehensive text on computer vision and deep learning, and a good introductory text on PyTorch are all invaluable resources for deepening your understanding. Focusing on these materials will provide the necessary background to effectively utilize and extend the provided code examples.  Mastering NumPy array manipulation is also paramount for efficient processing of YOLOv5 outputs.  Understanding the intricacies of tensor operations, especially within the PyTorch framework, will enhance your ability to adapt and extend the code for various applications.
