---
title: "How can a naive moving average be implemented in an FPGA?"
date: "2025-01-30"
id: "how-can-a-naive-moving-average-be-implemented"
---
Implementing a naive moving average filter in an FPGA presents unique challenges and opportunities compared to its software counterpart. The inherent parallelism of hardware description languages, like VHDL or Verilog, allows for highly efficient processing of streaming data, although the fixed-point nature of most FPGAs requires careful consideration. In my experience designing custom sensor processing pipelines, I've found that understanding the trade-offs between resource utilization, latency, and precision is crucial for a successful implementation.

The core concept of a naive moving average involves summing a fixed number of consecutive input samples and then dividing by the number of samples. In an FPGA, this translates to storing the past `N` samples in a register file, summing these registers at each clock cycle, and then performing a division operation. The division is often the most complex aspect due to the lack of hardware division units on many low to mid-range FPGAs. Thus, it is often approximated or implemented with techniques like shifting or lookup tables.

**Explanation:**

The implementation begins by establishing a data path for incoming data, usually driven by a clock signal. Incoming data samples are sequentially loaded into a register file, often implemented using a shift register or a RAM block configured as a FIFO. Simultaneously, all registers in the file are summed by an adder tree. The summed value is subsequently subjected to the division process, which, as previously mentioned, requires special handling due to hardware limitations.

The size of the register file corresponds to the window length (`N`) of the moving average. A larger window reduces noise but introduces more latency. Latency is a critical parameter in real-time applications, as the average output lags behind the current input. The choice of `N` is typically based on the trade-off between noise reduction and acceptable delay.

The numerical representation used in the FPGA heavily influences the precision of the filter. Fixed-point arithmetic is the standard in FPGAs due to its efficient hardware implementation. Careful allocation of bits is needed for both the input data and the register file to prevent overflow during the summation process. In my past projects, I have observed that it is vital to carefully analyze the expected range of input data before selecting bit widths.

The division can be addressed using a few strategies. When `N` is a power of two, a simple bit shift to the right can achieve division. When the window size is not a power of two, a more resource-intensive hardware divider can be implemented or a lookup table can be used to approximate the inverse of N, which is then multiplied with the sum. This approach is often a preferred alternative because multipliers are generally more efficient than dividers.

**Code Examples:**

These examples use Verilog for illustration.

**Example 1: Moving average with window size of 4 using bit-shift division.**

```verilog
module moving_average_4 (
  input clk,
  input reset,
  input signed [15:0] data_in,
  output signed [15:0] data_out
);

  reg signed [15:0] buffer [0:3]; // Register file
  reg signed [31:0] sum;

  integer i;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      for (i = 0; i < 4; i = i + 1)
        buffer[i] <= 0;
      sum <= 0;
    end else begin
      buffer[0] <= data_in; // Shift in new value
      buffer[1] <= buffer[0];
      buffer[2] <= buffer[1];
      buffer[3] <= buffer[2];


      sum <= buffer[0] + buffer[1] + buffer[2] + buffer[3];
    end
  end
    assign data_out = sum >>> 2; // Bit shift for division by 4 (2^2)
endmodule
```

*Commentary:* This code implements a simple 4-point moving average. The register file `buffer` stores the past four samples, and each sample is shifted through the registers at each clock cycle. The `sum` register accumulates the current values of the registers and the output, `data_out`, is computed by a right shift by two. This is the most basic implementation. The assumption is that the data is in a 16-bit signed format.

**Example 2: Moving average with a general window size using a multiplication by inverse technique.**

```verilog
module moving_average_variable (
    input clk,
    input reset,
    input signed [15:0] data_in,
    input [7:0] window_size,
    output signed [15:0] data_out
);
    parameter MAX_WINDOW = 256; // Maximum window size supported
    reg signed [15:0] buffer [0:MAX_WINDOW-1];
    reg signed [31:0] sum;
    reg [7:0] count;
    reg signed [31:0] inverse_table [2:MAX_WINDOW-1]; // Lookup table for inverse
    integer i;

    // initialize the lookup table (example, should be generated by a script)
    initial begin
        for (i=2;i<MAX_WINDOW;i=i+1) begin
             inverse_table[i] = (2**16)/i; // Approximate the inverse. 
        end
    end


    always @(posedge clk or posedge reset) begin
      if(reset) begin
         count <= 0;
         for (i=0;i<MAX_WINDOW;i = i+1) begin
            buffer[i] <= 0;
         end
           sum <= 0;
      end else begin
        if (count < window_size) begin
            buffer[count] <= data_in;
            count <= count + 1;
        end else begin
            buffer[0] <= data_in;
            for (i = 1; i<window_size; i=i+1) begin
             buffer[i] <= buffer[i-1];
             end
        end
        sum <=0;
        for (i=0; i< window_size; i=i+1) begin
           sum <= sum + buffer[i];
         end
      end
    end

    assign data_out = (sum * inverse_table[window_size]) >>> 16;


endmodule
```

*Commentary:* This example demonstrates the use of a lookup table to approximate the division. The `inverse_table` is initialized with pre-calculated values of `(2^16)/N`, which we use to multiply the sum and then use a right shift to obtain the final value. The `window_size` input allows us to control the moving average window dynamically, up to `MAX_WINDOW` which is set to 256 in this instance. Note that an initial block is used for demonstration purposes and should be computed offline.

**Example 3: Pipeline implementation for throughput increase.**

```verilog
module moving_average_pipelined (
    input clk,
    input reset,
    input signed [15:0] data_in,
    output signed [15:0] data_out
);

  parameter WINDOW_SIZE = 4;
  reg signed [15:0] buffer [0:WINDOW_SIZE-1];
  reg signed [31:0] sum_stage1, sum_stage2;
  reg signed [31:0] shifted_sum;
  integer i;

    always @(posedge clk or posedge reset) begin
      if (reset) begin
         for (i = 0; i< WINDOW_SIZE; i=i+1) begin
            buffer[i] <= 0;
         end
        sum_stage1 <= 0;
        sum_stage2 <= 0;
        shifted_sum <= 0;
      end else begin
          buffer[0] <= data_in;
           for (i = 1; i < WINDOW_SIZE; i= i+1) begin
              buffer[i] <= buffer[i-1];
             end
        sum_stage1 <= buffer[0] + buffer[1];
        sum_stage2 <= buffer[2] + buffer[3];
        shifted_sum <= (sum_stage1 + sum_stage2) >>> 2;
       end
    end

    assign data_out = shifted_sum;
endmodule
```

*Commentary:* This demonstrates pipelining for increased throughput. The summation is split into two stages, reducing the critical path of the combinational logic and enabling higher clock speeds. Data shifts through the `buffer` and the sums are accumulated in different pipeline stages (`sum_stage1`, `sum_stage2`). The final division is performed by a shift in the last stage, `shifted_sum`, for increased throughput and at the cost of a small amount of latency.

**Resource Recommendations:**

When exploring this topic further, I recommend studying the following materials:

1.  **FPGA vendor documentation:** Each FPGA manufacturer provides specific guides and application notes on arithmetic implementations in FPGAs. These vendor-specific resources are crucial for understanding the architectural details of the target device.
2.  **Textbooks on digital signal processing:** Books focusing on digital filter design techniques provide essential theoretical foundations for understanding the moving average filter and its variants. These texts often cover the finite word-length effects relevant to FPGA implementations.
3. **SystemVerilog / VHDL code libraries:** Examining well-documented, open source code libraries of digital signal processing functions can offer detailed examples of common implementations techniques for use within an FPGA environment.
4. **Scientific and engineering publications:**  Journals and conferences specializing in hardware architectures and signal processing often feature research on novel implementation of filters for use in FPGA environments, providing insight into state-of-the-art methods.

In conclusion, while a naive moving average is conceptually simple, its effective FPGA implementation necessitates careful management of resources, numerical precision, and latency. Choosing appropriate techniques for division and considering pipelining are vital for achieving optimal performance for a given application. Thorough analysis of the system's requirements and a study of the target FPGA platform architecture are key to a successful design.
