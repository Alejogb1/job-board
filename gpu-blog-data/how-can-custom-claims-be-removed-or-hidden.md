---
title: "How can custom claims be removed or hidden from Azure B2C access tokens?"
date: "2025-01-30"
id: "how-can-custom-claims-be-removed-or-hidden"
---
Azure B2C's extensibility, while powerful, sometimes leads to scenarios where initially included custom claims become unnecessary or even pose security risks.  My experience working on a large-scale identity and access management system for a global financial institution highlighted this precisely.  We initially incorporated several custom claims for internal auditing and reporting, but later discovered their presence in access tokens presented unnecessary exposure.  Efficiently removing or concealing these claims requires a multi-faceted approach targeting both the token issuance process and the application's claim consumption.

**1.  Modifying the User Journey and Claims Transformation Policies:**

The core solution involves carefully manipulating the Azure B2C user journey and its associated claims transformation policies. Custom claims are added to access tokens through these policies.  Removing them requires identifying the policy responsible and refining it to exclude the unwanted claims. This is achieved by editing the `ClaimsTransformation` element within the XML structure of your policy.  The specific approach depends on whether you are using built-in or custom policies.  With custom policies, you have more granular control, while built-in policies offer a more streamlined, albeit less flexible, process.

Directly deleting the claim from a `ClaimsTransformation` is seldom sufficient.  The claim might be implicitly generated by another policy or a relying party.  Instead, focus on using `ClaimType` and `ClaimTransformationMethod` elements to filter or transform the claims before they are issued in the token.


**2.  Code Examples illustrating claim manipulation:**

**Example 1:  Using a Custom Policy to remove a claim entirely:**

This example demonstrates how to use a `ClaimsTransformation` to filter out a specific custom claim, identified by its `ClaimType`,  before it is added to the access token.

```xml
<ClaimsTransformation>
  <InputClaims>
    <ClaimType>extension_MyCustomClaim</ClaimType>
    <ClaimType>extension_AnotherCustomClaim</ClaimType>  <!-- Example of retaining other claims -->
  </InputClaims>
  <OutputClaims>
    <OutputClaim ClaimTypeReferenceId="extension_AnotherCustomClaim"/>
  </OutputClaims>
</ClaimsTransformation>
```

This snippet, inserted within the relevant `ClaimsTransformation` policy, explicitly excludes `extension_MyCustomClaim`.  Note that only `extension_AnotherCustomClaim` is included in the output. This directly removes the unwanted claim from the token.  Remember to replace `extension_MyCustomClaim` and `extension_AnotherCustomClaim` with your actual claim types.


**Example 2:  Transforming a Claim to a different ClaimType for Obfuscation:**

Instead of complete removal, you might prefer to mask the claim's original value. This approach is useful for retaining the claim's underlying data for internal purposes while preventing unauthorized access.

```xml
<ClaimsTransformation>
  <InputClaims>
    <ClaimType>extension_SensitiveData</ClaimType>
  </InputClaims>
  <OutputClaims>
    <OutputClaim ClaimType="extension_ObfuscatedData" TransformationMethod="Hashing">
      <InputClaimsTransformations>
        <InputClaim ClaimTypeReferenceId="extension_SensitiveData"/>
      </InputClaimsTransformations>
    </OutputClaim>
  </OutputClaims>
</ClaimsTransformation>
```

This code snippet takes the `extension_SensitiveData` claim, processes it using a hashing algorithm specified by `TransformationMethod="Hashing"`, and then re-emits it under the new `ClaimType`, `extension_ObfuscatedData`.  The original sensitive value is effectively hidden, with the hashed value only being accessible via the appropriate decoding mechanism within your internal applications.  Consider utilizing strong hashing algorithms for enhanced security.


**Example 3:  Conditional Claim Emission in Custom Policies:**

A more advanced technique involves conditionally issuing claims based on certain conditions within the user journey. This allows for granular control over which claims are included in the token, dependent on specific user attributes or application context.

```xml
<ClaimsTransformation>
  <InputClaims>
    <ClaimType>extension_InternalUseClaim</ClaimType>
  </InputClaims>
  <OutputClaims>
    <OutputClaim ClaimTypeReferenceId="extension_InternalUseClaim" When="IsUserAdmin eq true"/>
  </OutputClaims>
</ClaimsTransformation>
```

This illustrates a conditional output. `extension_InternalUseClaim` is only added to the token (`When="IsUserAdmin eq true"`) if the user is determined to be an administrator. This uses a condition expression â€“ you would define `IsUserAdmin` appropriately earlier in your policy.  This ensures that the claim is only present for authorized users and administrators, reducing potential security risks.


**3.  Application-Side Handling:**

Even with effective policy adjustments, it's crucial to ensure that your applications properly handle the modified token.  If your application relies on a claim that has been removed or transformed, you must adapt your code accordingly. This involves updating your code to either ignore the claim or utilize the transformed version.  Failing to do this could result in application errors or unexpected behaviour.

This necessitates a rigorous testing process after modifying the claims policies.  Thoroughly test all application flows to guarantee that no functionality is inadvertently broken due to the removal or alteration of claims.

**4.  Resource Recommendations:**

Microsoft's official Azure Active Directory documentation, focusing on Azure B2C's custom policies and claims transformation.  Detailed guides on XML schema for custom policies and troubleshooting common claims-related issues are essential.  Also, leverage the community forums dedicated to Azure B2C; experienced developers often share best practices and solutions to complex scenarios involving claims management.  Finally, investing in a comprehensive understanding of security best practices within the context of OAuth 2.0 and OpenID Connect will significantly aid in designing robust and secure identity solutions.


In summary, removing or hiding custom claims from Azure B2C access tokens requires careful manipulation of claims transformation policies.  A combination of claim exclusion, transformation, and conditional emission, coupled with updated application logic, offers a robust and secure approach to managing sensitive information within access tokens.  Remember that a comprehensive understanding of Azure B2C's architecture and security best practices is paramount to achieving a successful implementation.
