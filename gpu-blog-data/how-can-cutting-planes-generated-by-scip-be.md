---
title: "How can cutting planes generated by SCIP be saved?"
date: "2025-01-30"
id: "how-can-cutting-planes-generated-by-scip-be"
---
SCIP, by default, does not automatically persist generated cutting planes across solve sessions. While it dynamically creates and manages these during the optimization process, that state is not preserved for subsequent runs unless explicitly requested. From my experience working on large-scale logistics optimization problems, this limitation can be frustrating; pre-computed cuts can significantly speed up the solution process, especially when similar problem instances are solved repeatedly. The challenge, then, is to understand how to extract and then reuse these cutting planes. SCIP provides functionality to access the generated cuts and store them externally, allowing for subsequent problem loading and constraint addition.

The process essentially involves three distinct stages: first, solving the initial problem, enabling cutting plane storage, and accessing those stored cuts; second, creating the mechanism for storing the extracted cuts persistently; and third, reloading these cuts into a new SCIP instance. Let's examine the relevant SCIP functionalities and then provide specific coding examples demonstrating how this can be achieved in C, a language where I've spent considerable time interfacing with SCIP.

Initially, after solving a model instance, cutting planes are stored within the *SCIP* data structure itself, managed by the cutting plane pool. Directly extracting them typically requires iterating through this pool, using functions provided within the SCIP API. The core functions here are `SCIPgetNOrigCuts`, which returns the number of original cutting planes, and `SCIPgetOrigCut`, which retrieves a specific original cut given an index. A crucial point is that cutting planes in SCIP are represented by their data components: a left-hand side, right-hand side, coefficients and variables, along with any type of cut information. These details must be extracted carefully and stored appropriately.

The difficulty lies not so much in extraction as in creating a durable, reusable format for storing the cutting plane information. Plain text storage is possible, but it is less flexible and harder to maintain if the cut structure is at all complex. A better approach is to use a structured format, such as a comma-separated value (CSV) file, or binary serialization. For CSV, each row could store the left-hand side value, right-hand side value, a list of coefficients, a list of variable indices, and cut type. Binary serialization, while more complex initially, is more efficient and allows storing any necessary meta-data along with the cut, making it preferable for larger scale implementations. I have had success with defining a custom binary structure for cut storage, and I will demonstrate CSV in the examples below for clarity.

The final stage, which is loading the cutting planes into a new SCIP instance, requires a reverse process. We must read the stored cut data, create SCIP constraints and then add them to the current problem instance. The primary function here is `SCIPcreateConsLinear`, which allows us to construct a constraint given a left and right-hand side value, an array of variables, and an array of corresponding coefficients. This is the inverse to extracting them during the initial solve. Finally, it should be remembered that while the core constraints can be added, the efficacy of the stored cuts may vary depending on the problem instance and its similarities with the previous one.

Now, let’s explore the implementation with some concrete examples. The first example below shows the basic function for extracting cutting plane data into CSV format after an initial solve:

```c
#include "scip/scip.h"
#include "scip/scipdefplugins.h"
#include <stdio.h>
#include <stdlib.h>

void writeCutsToCSV(SCIP* scip, const char* filename) {
    FILE* fp = fopen(filename, "w");
    if (fp == NULL) {
        printf("Error opening file.\n");
        return;
    }

    int ncuts = SCIPgetNOrigCuts(scip);
    fprintf(fp, "lhs,rhs,coeffs,vars,cuttype\n"); // Header row
    for (int i = 0; i < ncuts; ++i) {
        SCIP_CUT* cut = SCIPgetOrigCut(scip, i);
        SCIP_Real lhs = SCIPcutGetLhs(cut);
        SCIP_Real rhs = SCIPcutGetRhs(cut);
        int nvars = SCIPcutGetNVars(cut);
        SCIP_Real* coeffs = SCIPcutGetCoefs(cut);
        SCIP_VAR** vars = SCIPcutGetVars(cut);
        char* cuttype;
        if( SCIPcutGetType(cut) == SCIP_CUTTYPE_LOCAL ) {
          cuttype = "local";
        }
        else if ( SCIPcutGetType(cut) == SCIP_CUTTYPE_GLOBAL ){
          cuttype = "global";
        } else {
            cuttype = "unknown";
        }

        fprintf(fp, "%f,%f,\"", lhs, rhs); // Begin row
        for (int j = 0; j < nvars; ++j) {
            fprintf(fp, "%f", coeffs[j]);
            if (j < nvars - 1) fprintf(fp, ",");
        }
        fprintf(fp, "\",\""); // End coeffs, begin vars
        for (int j = 0; j < nvars; ++j) {
            fprintf(fp, "%d", SCIPvarGetIndex(vars[j]));
            if (j < nvars - 1) fprintf(fp, ",");
        }
        fprintf(fp, "\",%s\n", cuttype); // End vars and cut type, end row

    }
    fclose(fp);
}


// Example usage:
int main() {
    SCIP* scip;
    SCIPcreate(&scip);
    SCIPincludeDefaultPlugins(scip);

    //Load problem, solve, assuming model is loaded and solved here...
    SCIPreadProb(scip, "example.lp", NULL);
    SCIPsolve(scip);

    writeCutsToCSV(scip, "cuts.csv");

    SCIPfree(&scip);

    return 0;
}
```
This example demonstrates the basic mechanics of writing the cut data to a comma separated file. This is not suitable for all cases but shows how the data is accessed and what type of data is stored. The second example demonstrates the reverse process of reading a CSV file containing cut data and loading it into a fresh SCIP instance, creating the corresponding linear constraints. Note that this example requires that the model is loaded with the same variables indices as the previously solved problem.

```c
#include "scip/scip.h"
#include "scip/scipdefplugins.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void loadCutsFromCSV(SCIP* scip, const char* filename) {
    FILE* fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error opening file.\n");
        return;
    }

    char line[1024];
    fgets(line, sizeof(line), fp); // Skip header

    while (fgets(line, sizeof(line), fp)) {
        double lhs, rhs;
        char* token;

        token = strtok(line, ",");
        if (token == NULL) continue;
        lhs = atof(token);

        token = strtok(NULL, ",");
        if (token == NULL) continue;
        rhs = atof(token);


        token = strtok(NULL, "\"");
        if (token == NULL) continue;

        char* coeffs_str = token;

        token = strtok(NULL, "\"");
        if (token == NULL) continue;
        token = strtok(token + 1, "\"");
        if( token == NULL) continue;

        char* vars_str = token;

        token = strtok(NULL, ",");
        if( token == NULL) continue;

        char* cuttype_str = token;

        // Parse coefficients
        int ncoeffs = 0;
        double* coeffs = NULL;

        char* coeff_token = strtok(coeffs_str, ",");
        while( coeff_token != NULL ) {
          coeffs = (double*)realloc(coeffs, (ncoeffs + 1) * sizeof(double));
          coeffs[ncoeffs++] = atof(coeff_token);
          coeff_token = strtok(NULL,",");
        }

        // Parse variables
        int nvars = 0;
        int* vars = NULL;
        char* var_token = strtok(vars_str, ",");
         while (var_token != NULL){
            vars = (int*)realloc(vars, (nvars+1) * sizeof(int));
            vars[nvars++] = atoi(var_token);
            var_token = strtok(NULL, ",");
        }

        //add constraint
        SCIP_VAR** scip_vars = (SCIP_VAR**)malloc(nvars * sizeof(SCIP_VAR*));
        for (int i = 0; i < nvars; i++){
           scip_vars[i] = SCIPgetVar(scip, vars[i]);
        }
        SCIP_CONS* cons;
         SCIPcreateConsLinear(scip, &cons, "loadedCut", nvars, scip_vars, coeffs, lhs, rhs, true, true, true, true, true, false, false, false, false, false);
        SCIPaddCons(scip, cons);
        SCIP_CALL( SCIPreleaseCons(scip, &cons) );
        free(scip_vars);
        free(coeffs);
        free(vars);
    }
    fclose(fp);
}

// Example usage:
int main() {
  SCIP* scip;
  SCIPcreate(&scip);
  SCIPincludeDefaultPlugins(scip);

  //Load problem, solve
  SCIPreadProb(scip, "example.lp", NULL);

  loadCutsFromCSV(scip, "cuts.csv");
  SCIPsolve(scip);

  SCIPfree(&scip);
  return 0;
}
```

This example is a more complicated process; there is considerable memory management and parsing involved. Error handling is minimal for clarity, and you should handle cases with malformed CSV files in a real application. The final example highlights how cutting planes can be loaded only under specific conditions. In many of my projects, not all saved cuts were equally helpful. This example outlines a simple condition check that reads a boolean from a string.

```c
#include "scip/scip.h"
#include "scip/scipdefplugins.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

void loadCutsWithCondition(SCIP* scip, const char* filename, bool condition ) {
    FILE* fp = fopen(filename, "r");
    if (fp == NULL) {
        printf("Error opening file.\n");
        return;
    }

    char line[1024];
    fgets(line, sizeof(line), fp); // Skip header

    while (fgets(line, sizeof(line), fp)) {
        double lhs, rhs;
        char* token;

        token = strtok(line, ",");
        if (token == NULL) continue;
        lhs = atof(token);

        token = strtok(NULL, ",");
        if (token == NULL) continue;
        rhs = atof(token);

         token = strtok(NULL, "\"");
        if (token == NULL) continue;

        char* coeffs_str = token;

        token = strtok(NULL, "\"");
        if (token == NULL) continue;
        token = strtok(token + 1, "\"");
        if( token == NULL) continue;

        char* vars_str = token;

       token = strtok(NULL, ",");
        if( token == NULL) continue;
      
        char* cuttype_str = token;

        bool cutIsLocal = strcmp(cuttype_str, "local") == 0;

        if (condition == true && cutIsLocal == false){
            continue; //skip global cuts if condition is true.
        }

         // Parse coefficients
        int ncoeffs = 0;
        double* coeffs = NULL;

        char* coeff_token = strtok(coeffs_str, ",");
        while( coeff_token != NULL ) {
          coeffs = (double*)realloc(coeffs, (ncoeffs + 1) * sizeof(double));
          coeffs[ncoeffs++] = atof(coeff_token);
          coeff_token = strtok(NULL,",");
        }

        // Parse variables
        int nvars = 0;
        int* vars = NULL;
        char* var_token = strtok(vars_str, ",");
         while (var_token != NULL){
            vars = (int*)realloc(vars, (nvars+1) * sizeof(int));
            vars[nvars++] = atoi(var_token);
            var_token = strtok(NULL, ",");
        }

        //add constraint
        SCIP_VAR** scip_vars = (SCIP_VAR**)malloc(nvars * sizeof(SCIP_VAR*));
        for (int i = 0; i < nvars; i++){
           scip_vars[i] = SCIPgetVar(scip, vars[i]);
        }

        SCIP_CONS* cons;
         SCIPcreateConsLinear(scip, &cons, "loadedCut", nvars, scip_vars, coeffs, lhs, rhs, true, true, true, true, true, false, false, false, false, false);
        SCIPaddCons(scip, cons);
        SCIP_CALL( SCIPreleaseCons(scip, &cons) );

        free(scip_vars);
        free(coeffs);
        free(vars);
    }
    fclose(fp);
}

// Example usage:
int main() {
    SCIP* scip;
    SCIPcreate(&scip);
    SCIPincludeDefaultPlugins(scip);

    SCIPreadProb(scip, "example.lp", NULL);

    loadCutsWithCondition(scip, "cuts.csv", true); // load only local cuts
    SCIPsolve(scip);

    SCIPfree(&scip);
    return 0;
}
```
This example illustrates an additional level of complexity, loading cuts conditionally. In practice, more sophisticated conditions would likely be employed based on cut type or generation properties to get maximum utility. I have often found myself using custom filters similar to this to get the most out of stored cuts.

In conclusion, while SCIP doesn’t automatically save cutting planes, the capability to extract, store, and reload them is readily accessible through its API. Choosing an appropriate storage format, like CSV demonstrated here, or binary serialization for more intricate cut data, is crucial. Loading these cuts requires careful handling of variable indices. For more detailed information, the SCIP documentation provides a complete overview of all available functions and their parameters, which I have frequently referenced during my time using the framework. Furthermore, several online tutorials, while perhaps not specific to this topic, offer helpful insights into the general use of the SCIP API. I also suggest exploring the examples included in the SCIP distribution, which have often guided me in my implementations.
