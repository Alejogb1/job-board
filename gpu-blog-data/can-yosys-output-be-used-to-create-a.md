---
title: "Can Yosys output be used to create a simulation waveform?"
date: "2025-01-30"
id: "can-yosys-output-be-used-to-create-a"
---
Yosys, primarily a logic synthesis tool, generates a netlist, a description of the interconnected logic gates in a hardware design. This netlist, by itself, cannot directly produce a simulation waveform. However, Yosys’s output, specifically its structural representation, provides the foundation upon which a simulation environment can be constructed, typically in conjunction with other tools. My experience converting several gate-level designs into verification-ready simulations highlights the necessary steps and considerations.

The core issue is that Yosys's primary purpose is transforming a high-level Register Transfer Level (RTL) description, usually in Verilog or VHDL, into an optimized gate-level netlist. This netlist, while functionally equivalent to the RTL, omits crucial timing and stimulus information necessary for a dynamic simulation. To simulate a design described by a Yosys netlist, an intermediate translation stage is required to transform the structural information into a format suitable for a simulator, such as a Verilog testbench or a VHDL test fixture. This process involves:

1.  **Netlist Conversion:** The Yosys output, often in `.v` (Verilog) or `.vhd` (VHDL) format, needs to be read and understood. This requires parsing the syntax, extracting the module instantiation hierarchy, and identifying the ports and interconnections.

2.  **Testbench/Test Fixture Generation:** A separate testbench (Verilog) or test fixture (VHDL) file is needed to provide the required stimulus. This involves declaring signals, applying inputs, and observing outputs. For a gate-level simulation, the testbench should instantiate the gate-level netlist generated by Yosys. This is where we encounter a challenge: the synthesized netlist lacks timing constraints. These constraints, specified in a Standard Delay Format (SDF) file, are not generated by Yosys during typical synthesis. They must be acquired from the synthesis tools of the specific target technology library.

3.  **Simulator Integration:** The simulator, such as Verilator, Icarus Verilog (iverilog), or a commercial simulator, reads both the gate-level netlist and the testbench. The simulator then calculates the logic behavior and produces a waveform output, often in formats like `.vcd` (Value Change Dump) or `.fsdb` (Fast Signal Database).

Here are examples demonstrating this process, using Verilog syntax for the netlist and testbench.

**Example 1: Simple Combinational Logic**

Imagine a simple AND gate circuit, synthesized by Yosys. The generated Verilog netlist `and_gate.v` might look like this:

```verilog
module and_gate (input a, input b, output out);
  and U1 (out, a, b);
endmodule
```

A testbench for this would need to instantiate this module and apply stimulus, contained in a separate file, `and_gate_tb.v`:

```verilog
module and_gate_tb;
  reg a, b;
  wire out;

  and_gate dut (.a(a), .b(b), .out(out));

  initial begin
    $dumpfile("and_gate.vcd");
    $dumpvars(0, and_gate_tb);
    a = 0; b = 0; #10;
    a = 0; b = 1; #10;
    a = 1; b = 0; #10;
    a = 1; b = 1; #10;
    $finish;
  end
endmodule
```

**Commentary:** Here the `and_gate_tb.v` file instantiates the `and_gate` module. The initial block defines the input stimulus and initiates the waveform dumping process with `$dumpfile` and `$dumpvars`. The `#10` delays introduce time progression for the simulation. When compiled using a Verilog simulator with both files, it would produce a `.vcd` waveform output showing the `out` signal transitioning based on the applied inputs.

**Example 2: Sequential Logic with a Flip-Flop**

Consider a D flip-flop with a clock and reset. The synthesized netlist `dff.v` might be:

```verilog
module dff (input d, input clk, input rst, output q);
  dffsr U1 ( .d(d), .clk(clk), .set(1'b0), .rst(rst), .q(q), .qn() );
endmodule
```

The testbench in `dff_tb.v` would be more involved to demonstrate a clock edge:

```verilog
module dff_tb;
  reg d, clk, rst;
  wire q;

  dff dut (.d(d), .clk(clk), .rst(rst), .q(q));

  initial begin
    $dumpfile("dff.vcd");
    $dumpvars(0, dff_tb);
    clk = 0; rst = 1; d = 0; #10;
    rst = 0; d = 1; #10;
    clk = 1; #10;
    clk = 0; #10;
    clk = 1; #10;
    d = 0; #10;
    clk = 0; #10;
    $finish;
  end

  always #5 clk = ~clk;
endmodule
```

**Commentary:** The key difference here is the clock generation using an `always` block and the reset assertion in the initial block. The d input changes and the changes propagate to the `q` output on clock rising edges as expected.  The `#5` introduces clock period generation, critical for sequential logic simulation. This simulation requires the simulator to understand the behavior of the flip-flop, usually through an internal model from the technology library, which is not contained in the Yosys output itself.

**Example 3:  A Counter Module**

Let's synthesize a simple 4-bit counter, leading to a Yosys output `counter.v` (simplified for brevity; the actual gate structure can be far more complex):

```verilog
module counter (input clk, input rst, output [3:0] count);
  dffsr U0 ( .d(count[0] ^ 1'b1), .clk(clk), .set(1'b0), .rst(rst), .q(count[0]), .qn() );
  dffsr U1 ( .d(count[0] ^ count[1]), .clk(clk), .set(1'b0), .rst(rst), .q(count[1]), .qn() );
  dffsr U2 ( .d(count[0] ^ count[1] ^ count[2]), .clk(clk), .set(1'b0), .rst(rst), .q(count[2]), .qn() );
  dffsr U3 ( .d(count[0] ^ count[1] ^ count[2] ^ count[3]), .clk(clk), .set(1'b0), .rst(rst), .q(count[3]), .qn() );
endmodule
```

The testbench in `counter_tb.v` to observe the counter increment:

```verilog
module counter_tb;
  reg clk, rst;
  wire [3:0] count;

  counter dut (.clk(clk), .rst(rst), .count(count));

    initial begin
      $dumpfile("counter.vcd");
      $dumpvars(0, counter_tb);
      rst = 1; clk = 0; #10;
      rst = 0; #10;
      repeat (16) #10 clk = ~clk;
      $finish;
   end

   always #5 clk = ~clk;
endmodule
```

**Commentary:** The testbench first asserts reset, then releases it, and then cycles the clock. The repeated clock transition in the initial block drives the count and allows visualization of the counter incrementing in the VCD. Again, the detailed delay behavior seen in a simulator is not encoded in the `.v` file generated by Yosys itself, requiring the underlying timing models in the simulator for accurate waveform creation.

In summary, Yosys’s output provides the necessary *structure* of a hardware design but lacks the temporal information required for direct simulation.  Tools that can read a Verilog netlist and incorporate SDF (Standard Delay Format) timing information are necessary to produce accurate waveforms. Therefore, an additional layer of conversion and testbench writing is essential. Resources like the Verilog LRM (Language Reference Manual) for testbench structure, books on digital logic design with simulation techniques, and the user manuals for specific simulator tools such as Verilator or Icarus Verilog are recommended for further study. These materials provide comprehensive knowledge regarding simulation flow, timing analysis, and creating appropriate test environments.
