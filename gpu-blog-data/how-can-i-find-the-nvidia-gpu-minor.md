---
title: "How can I find the NVIDIA GPU minor number from its UUID?"
date: "2025-01-30"
id: "how-can-i-find-the-nvidia-gpu-minor"
---
The minor number of an NVIDIA GPU, which is an integer value used by the operating system to distinguish between multiple GPUs, is not directly encoded within the GPU’s UUID (Universally Unique Identifier). The UUID is a globally unique identifier generated by the NVIDIA driver to identify the specific physical device. Consequently, a mapping must be established between the UUID and its corresponding minor number, primarily through system calls or library functions. My experience maintaining a large-scale GPU cluster has involved frequent retrieval of this association for resource management and job scheduling. This process typically relies on the NVIDIA Management Library (NVML) API.

The underlying mechanism involves querying the system’s available GPUs, each of which is assigned a unique index. During this enumeration, the NVML retrieves both the UUID and the minor number of each GPU. Thus, finding the minor number from the UUID necessitates an iterative search process. Specifically, the application requests all present GPUs, obtains their UUIDs and minor numbers, and then iterates through this collection, comparing each UUID with the target UUID. Once a match is found, the corresponding minor number is retrieved. This approach is crucial because the minor number assignment is dynamic and can change upon driver updates or device hot-plugging.

The NVML API is the preferred method for extracting GPU information due to its direct communication with the NVIDIA driver, minimizing overhead and ensuring accuracy. The alternative of parsing system files is neither recommended nor reliable. NVML is a C-based API and is available on Linux and Windows. Language bindings exist for several languages, such as Python. Utilizing these bindings reduces development time and allows for easier integration. While the core process remains similar irrespective of the language used, the code examples below demonstrate implementations using both the C interface and Python bindings for clarity.

**C Code Example**

```c
#include <stdio.h>
#include <string.h>
#include <nvml.h>

int main() {
    nvmlReturn_t result;
    unsigned int device_count, i;
    char uuid_str[NVML_DEVICE_UUID_BUFFER_SIZE];
    nvmlDevice_t device;
    unsigned int minor_number;
    const char *target_uuid = "GPU-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"; // Replace with the UUID you are looking for

    result = nvmlInit();
    if (result != NVML_SUCCESS) {
        fprintf(stderr, "Failed to initialize NVML: %s\n", nvmlErrorString(result));
        return 1;
    }

    result = nvmlDeviceGetCount(&device_count);
    if (result != NVML_SUCCESS) {
        fprintf(stderr, "Failed to get device count: %s\n", nvmlErrorString(result));
        nvmlShutdown();
        return 1;
    }

    for (i = 0; i < device_count; i++) {
        result = nvmlDeviceGetHandleByIndex(i, &device);
        if (result != NVML_SUCCESS) {
            fprintf(stderr, "Failed to get device handle for index %u: %s\n", i, nvmlErrorString(result));
            continue;
        }

        result = nvmlDeviceGetUUID(device, uuid_str, NVML_DEVICE_UUID_BUFFER_SIZE);
        if (result != NVML_SUCCESS) {
            fprintf(stderr, "Failed to get device UUID for index %u: %s\n", i, nvmlErrorString(result));
            continue;
        }
        
        if (strcmp(uuid_str, target_uuid) == 0) {
            result = nvmlDeviceGetMinorNumber(device, &minor_number);
            if(result == NVML_SUCCESS)
            {
              printf("Minor number for UUID %s: %u\n", target_uuid, minor_number);
            } else {
               fprintf(stderr, "Failed to get minor number for device with uuid %s: %s\n", target_uuid, nvmlErrorString(result));
            }
            nvmlShutdown();
            return 0;
        }
    }

    printf("Device with UUID %s not found\n", target_uuid);
    nvmlShutdown();
    return 1;
}
```
This C code initializes the NVML library, retrieves the number of available devices and then iterates over each one, obtaining the UUID and comparing it to the user provided target UUID. If a match is found, the associated minor number is retrieved, and the result is output to the console. Note that in case of not finding the requested UUID, the process will also shut down NVML and return a non-zero exit code. The NVML errors are also handled to properly display the root cause of an error.

**Python Code Example**

```python
import py3nvml.py3nvml as nvml

def get_minor_number_from_uuid(target_uuid):
    try:
        nvml.nvmlInit()
        device_count = nvml.nvmlDeviceGetCount()
        for i in range(device_count):
            handle = nvml.nvmlDeviceGetHandleByIndex(i)
            uuid = nvml.nvmlDeviceGetUUID(handle).decode()

            if uuid == target_uuid:
                minor_number = nvml.nvmlDeviceGetMinorNumber(handle)
                print(f"Minor number for UUID {target_uuid}: {minor_number}")
                nvml.nvmlShutdown()
                return minor_number
        print(f"Device with UUID {target_uuid} not found.")
    except nvml.NVMLError as error:
            print(f"NVML error: {error}")
    finally:
      nvml.nvmlShutdown()
    return None


if __name__ == "__main__":
    target_uuid = "GPU-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" # Replace with the actual UUID
    get_minor_number_from_uuid(target_uuid)
```

This Python code performs an analogous function to the C code utilizing `py3nvml` (Python 3 bindings for NVML). It initializes NVML, gets the available devices count, iterates through each, compares the UUIDs, and retrieves the associated minor number if the UUID matches, before exiting with the correct result. The error handling includes a catch-all for NVML errors and a final call to shutdown NVML. This simplifies the usage of NVML for Python developers.

**Go Code Example**

```go
package main

import (
	"fmt"
	"log"
	"strings"

	"github.com/NVIDIA/go-nvml/pkg/nvml"
)

func main() {
    targetUUID := "GPU-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" // Replace with the UUID you are looking for

	err := nvml.Init()
	if err != nil {
		log.Fatalf("Unable to initialize NVML: %v", err)
	}
    defer func() {
        if err := nvml.Shutdown(); err != nil {
            log.Printf("error shutting down nvml: %v", err)
        }
    }()

	deviceCount, err := nvml.GetDeviceCount()
	if err != nil {
		log.Fatalf("Unable to get device count: %v", err)
	}

	for i := 0; i < deviceCount; i++ {
		device, err := nvml.GetDeviceHandleByIndex(i)
		if err != nil {
			log.Printf("Unable to get device at index %d: %v", i, err)
			continue
		}
        uuid, err := device.GetUUID()
        if err != nil{
            log.Printf("Unable to get uuid for device at index %d: %v", i, err)
            continue
        }
		if strings.TrimSpace(uuid) == targetUUID {
            minorNumber, err := device.GetMinorNumber()
            if err != nil {
              log.Fatalf("Unable to get minor number for device with uuid %s: %v", targetUUID, err)
              return
            }
            fmt.Printf("Minor number for UUID %s: %d\n", targetUUID, minorNumber)
            return
        }
	}
	fmt.Printf("Device with UUID %s not found\n", targetUUID)
}
```

This Go implementation shows how to achieve the same functionality utilizing the `go-nvml` bindings for the NVIDIA Management Library. It iterates through all devices, retrieving the UUID and comparing against the target UUID provided. If a match is found, the associated minor number is retrieved using the `GetMinorNumber` method from the device handle. Error handling is included for all relevant API calls, ensuring proper resource cleanup at the end. The string comparison also removes any leading and trailing spaces.

To effectively utilize these examples and the NVML library, refer to NVIDIA's official documentation for the NVML API. Specific programming language bindings should also come with their respective documentation; for instance, consult the documentation that ships with the `py3nvml` package for usage details, or the `go-nvml` repository documentation for the same. These references will provide specific information regarding available functions, error codes and data types used. The NVIDIA developer forum can also be a valuable resource for troubleshooting and obtaining code examples for corner cases. Additionally, examine the source code for the NVML examples available on the NVIDIA's developer web site to become acquainted with the NVML library. Reviewing these resources will facilitate a deeper understanding of the library and enable the developer to adapt it to various situations.
