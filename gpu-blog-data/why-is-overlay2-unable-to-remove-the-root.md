---
title: "Why is overlay2 unable to remove the root filesystem?"
date: "2025-01-30"
id: "why-is-overlay2-unable-to-remove-the-root"
---
The inability of overlay2 to directly remove the root filesystem stems from its fundamental design as a union filesystem, not a replacement for the underlying storage. I've encountered this limitation repeatedly while working with container runtimes and building custom embedded systems, and it's crucial to understand why a seemingly straightforward deletion isn't feasible.

Overlay2 operates by layering directories on top of each other. It’s specifically designed for efficient snapshotting and the immutability of a base image. A typical overlay2 configuration involves a lower directory (read-only base image), an upper directory (read-write layer for modifications), and a merged directory presenting the unified view.  The key point here is that the root filesystem as perceived within a container or in a system using overlay2 isn't a singular, monolithic entity; rather, it's a virtual composition of the underlying layers. Attempts to remove the perceived root directory within the overlay2 context target the merged directory, which is not a real directory in the conventional sense, rather a representation generated by overlayfs using the provided lower and upper directories.

The lower directory is usually a base image that, from the overlayfs perspective, should remain immutable. The upper directory holds changes made by the running process.  Removing the 'root filesystem' as presented by the merged directory would involve a series of invalid operations, such as attempting to delete parts of the read-only lower directory or breaking the relationship that the merged directory has with the lower and upper. Such a behavior, if even possible, would fundamentally undermine the stability and consistency that overlay2 provides. Furthermore, deleting the upper directory, while superficially appearing as 'removal' of changes, will not remove the original lower directory; thus, a complete deletion remains elusive.

The problem is not a flaw in overlay2; it is a characteristic designed around the efficient sharing and immutability aspects of the layered approach. Trying to delete the “root” filesystem in this context is akin to attempting to delete the compiled program when you only have access to the running process and its memory mapping. You are interacting with a presentation of data, not the underlying storage structure.

Let's examine some examples.

**Example 1: A Basic Container Scenario**

Imagine a Docker container using overlay2.  The lower directory is your base image (e.g., `ubuntu:latest`), and the upper directory contains changes since you started the container. The merged directory presents the unified view, the "root filesystem" inside the container. The code example is conceptual, demonstrating the overlay2 structure and the impact of a remove operation. It's not literal shell commands but rather a representation of overlay2's layers and would require specific tooling to examine in practice:

```
// Assume the following file structure exists in your machine:

/var/lib/docker/overlay2/xyz123-lower  // Base image, READ ONLY
/var/lib/docker/overlay2/xyz123-upper  // Container writeable layer
/var/lib/docker/overlay2/xyz123-merged  // Virtual merged view, "root"

// Attempting a deletion within the container:

int main() {
    // Inside the container, '/'' points to the merged directory.
    remove("/"); // This operation FAILS because it targets a virtual directory
    remove("/path/to/a/file/in/upper"); //This is successful, it removes from the upper
    return 0;
}

// Commentary: The remove("/") call fails because it targets the merged view
//             that isn’t backed by a physical, single, deletable directory.
//             The second removal works because it targets a specific file in the writeable layer.
//             The overlay2 structure continues to exist.
```

In this example, `remove("/")` (represented conceptually) fails because `/` is the merged directory, not a concrete, single directory. The virtual root isn’t designed for deletion in this way; instead it points to the composition of the lower and upper layers. Trying to delete the merged view is akin to pulling the rug from under your own feet in the container runtime, and the system will correctly prevent that kind of operation. However, modifications within the writeable upper layer can be removed, demonstrating its mutable nature.

**Example 2: A Custom Overlay2 Setup**

Suppose we created an overlay2 setup manually for experimentation, perhaps using mount commands:

```
// Assume these directories exist:

/mnt/lower_dir  // Lower read-only directory, containing files
/mnt/upper_dir  // Upper writable directory, initialized empty
/mnt/merged     // Target mount point for overlay2

// Code using system calls for mounting. Requires root privileges. Not runnable without appropriate privileges

// In reality, mounting would require system calls or utilities, but for clarity we demonstrate with pseudo-code
mount("-t", "overlay", "-o", "lowerdir=/mnt/lower_dir,upperdir=/mnt/upper_dir,workdir=/tmp/workdir", "/mnt/merged")

// Trying to remove from the merged view:
remove("/mnt/merged") // This also FAILS, for similar reasons as the container.
// Trying to remove parts of the lower view
remove("/mnt/lower_dir/specificfile.txt") // This fails as lower_dir is read-only
remove("/mnt/upper_dir/specificfile.txt") // This succeeds as upper_dir is writable

// To actually remove overlay2:
umount("/mnt/merged") // This is necessary to unmount the overlay
// Now we can remove both /mnt/lower_dir and /mnt/upper_dir if we chose
// Removing the lower directory is not desirable if other overlayfs mountpoints are relying on it.

// Commentary:  We can see that the remove operation again does not affect overlay2's functionality
//   Instead, the unmount operation must be used to properly remove the mount point.
//   The lower directory cannot be deleted directly either while the mount is alive.
//   The deletion must happen after unmounting.
```

Here, the `remove("/mnt/merged")` call will fail, reinforcing that you are interacting with a merged view, not a concrete directory. You can modify things within the `upperdir` layer, but deleting the merged view doesn't delete the underlying layers, and those layers must be dealt with through the appropriate unmounting operations. This is a crucial concept in understanding the separation of concerns between overlayfs and the files it represents.

**Example 3:  A Programmatic (Conceptual) Approach**

Let's represent this with conceptual code that would likely not directly compile, but illustrates the concept through a made-up API call for simplicity:

```
struct overlay_layer {
   char* layer_path;
   bool read_only;
};

struct overlay_mount {
  overlay_layer lower_layer;
  overlay_layer upper_layer;
  char* mount_point;
};

// Simplified representation of the overlay2 structure
overlay_mount my_mount = { {"/var/lower", true}, {"/var/upper", false}, "/var/merged"};

// Fictional api to represent the overlayfs logic
void remove_overlay_path(overlay_mount *mount, char *path) {
     if ( strcmp(path, mount->mount_point) == 0) {
        //attempt to remove the merged view
        //this will fail as it would be an invalid operation.
        printf("ERROR: Cannot remove merged view, unmount first.\n");
     } else {
         if (startsWith(path, mount->upper_layer.layer_path)){
             remove(path) //this would potentially work, targeting the writeable layer
         } else if (startsWith(path, mount->lower_layer.layer_path)){
            printf("ERROR: Cannot remove from lower layer, read-only.\n");
         }
         else{
            printf("ERROR: Invalid Path\n");
         }
    }
}

int main(){
 remove_overlay_path(&my_mount,"/var/merged"); //Fails as it’s attempting to remove the mount point
 remove_overlay_path(&my_mount,"/var/upper/testfile.txt"); //Successfully removes a file
 remove_overlay_path(&my_mount, "/var/lower/somefile.txt"); //Fails as it's read-only.
 return 0;
}

// Commentary: The fictional API show that the function would refuse to remove the
//             merged directory, while allowing removing specific files in the upper layer
//             or failing when attempting to remove files in the read-only layer
//            This represents the behavior of overlay2.
```

This code provides a high-level understanding: removing the merged directory directly is blocked by design. The API would allow the user to interact with files within the upper layer, while access to the lower layer is restricted.

In summary, overlay2 prevents direct removal of the root filesystem (as perceived in the merged view) because it doesn’t exist as a real directory. The merged view is a composite representation. Trying to `remove("/")` in the context of a container or overlayfs mount will target this composite and not a true physical, singular directory.

To actually "remove" overlay2, you would need to unmount the overlay mount point and then potentially remove both the lower and upper directories based on your specific scenario.

**Resource Recommendations:**

For further exploration of these topics, I recommend researching the documentation for Linux kernel virtual filesystems, specifically focusing on overlayfs. Explore resources about container runtimes like Docker and containerd, which are heavy users of overlay2. Lastly, consider studying the system calls related to mounting and unmounting filesystems. Understanding the kernel's approach to virtual filesystems will give you a deeper insight into overlay2 limitations. Reading through source code of these systems will also provide invaluable understanding.
