---
title: "How can debug symbols be retained when profiling C++ code on Windows?"
date: "2025-01-30"
id: "how-can-debug-symbols-be-retained-when-profiling"
---
Debugging symbols are paramount for interpreting performance profiles effectively. When profiling optimized C++ code on Windows, the default compiler and linker settings often strip these symbols, rendering profiles largely useless as they only show addresses without corresponding function names, line numbers, or variable context. This prevents identifying bottlenecks at the source code level. My experience working with a large rendering engine has made me keenly aware of this challenge, and I've developed a pragmatic approach to ensure debug symbol retention throughout the profiling process.

**Explanation of the Problem and Solution**

The issue stems from the way compilers and linkers operate to produce optimized builds. In release configurations, both the C++ compiler and the linker actively strive to reduce executable size. Symbol table information, including names, addresses, and type information, is not necessary for program execution. By stripping this data, the final executable and DLLs consume less disk space and memory, and improve loading times. However, this symbol stripping drastically hinders the capability to accurately profile performance as it obscures the link between execution timing data and the originating code.

Retaining these debug symbols involves configuring the compiler and linker to generate Program Database (PDB) files. A PDB file is a separate file that stores the debugging information required by debuggers and profilers. It allows mapping addresses back to the specific line of code that produced it. This file is typically associated with the executable (.exe) or dynamic link library (.dll) it was built from. Crucially, the existence of a PDB file does not hinder optimized performance; the PDB file is merely an external repository for this debug information and is not loaded by the program at runtime, unless explicitly requested by a debugger or profiler.

To achieve debug symbol retention, we must configure both the C++ compiler and the linker to generate PDBs and also ensure they are accessible during the profiling stage. This generally entails ensuring the PDB resides in the same directory as the executable or is discoverable by the profiler or debugger, either by specified symbol paths, or environmental variables. The exact configuration methods differ between compiler versions and build environments like Visual Studio or build automation tools. Typically, the most basic settings are enough, and the most important step is to avoid stripping the symbols during the linking phase.

**Code Examples and Commentary**

Here, I present three code examples demonstrating how symbol retention can be achieved in common build configurations within a Visual Studio environment, using a straightforward `CMake` build system. I am assuming the presence of a `CMakeLists.txt` file in the source code root directory:

**Example 1: Basic PDB Generation in Debug Build**

This example configures a basic CMake project to generate debug symbols in a debug build. It is not necessary to do anything here, in a standard visual studio cmake project, symbols are generated by default for debug builds. The compiler flags `/Zi` (which generates the PDB), and the linker flag `/DEBUG` are automatically added. It should be noted that `/Zi` is equivalent to `/ZI` in Cmake. It is included here for clarity and completenes:

```cmake
cmake_minimum_required(VERSION 3.15)
project(SymbolRetentionExample LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(SymbolRetentionExample main.cpp)

# Implicit PDB generation for Debug builds. No explicit action is needed, but setting the PDB output folder can be useful:
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
   set_property(TARGET SymbolRetentionExample PROPERTY PDB_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/pdbs")
endif()
```
*Commentary*: This CMake configuration defines the target executable `SymbolRetentionExample` and uses a standard approach. For Debug build configurations, the Visual C++ compiler will automatically generate and store the relevant PDB files in the `<binary_dir>/pdbs` folder. The crucial compiler flags required to do this are set by the CMake build environment. If a PDB output directory is not set as is the case for a default Debug build in visual studio, the PDB is put in the same directory as the executable. This example shows that no additional effort is generally required for debug builds in many visual studio environments.

**Example 2: Explicit PDB Generation in Release Build with /Zi and /DEBUG**

This example demonstrates forcing debug symbol generation even in a Release build by setting CMAKE_CXX_FLAGS_RELEASE and CMAKE_EXE_LINKER_FLAGS_RELEASE. This is often necessary when a full profile is needed of a release configuration.

```cmake
cmake_minimum_required(VERSION 3.15)
project(SymbolRetentionExample LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(SymbolRetentionExample main.cpp)

# Explicit PDB generation for Release builds. Using /Zi compiler flag, and /DEBUG linker flag
if(CMAKE_BUILD_TYPE STREQUAL "Release")
  set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /Zi")
  set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} /DEBUG /OPT:REF") # /OPT:REF required for optimizations
  set_property(TARGET SymbolRetentionExample PROPERTY PDB_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/pdbs")
endif()
```

*Commentary*: This snippet forces symbol generation even when a release configuration is selected. By using the `/Zi` (generate PDB file) compiler flag in `CMAKE_CXX_FLAGS_RELEASE`, we instruct the compiler to generate debug symbols. Similarly, the `/DEBUG` linker flag directs the linker to generate PDBs.  The `/OPT:REF` is additionally provided to allow full optimization. The output PDB file is stored in a `pdbs` folder inside the binary folder. This is crucial as normally the Release build would strip debug symbols for optimization.

**Example 3: Using /PROFILE and /INCREMENTAL (For Faster Build Times)**

This example explores incremental linking and profile guided optimization by using /PROFILE. This example is important, as incremental linking allows for faster rebuilds when changing source files. When /Zi is used, incremental linking is automatically enabled using `/INCREMENTAL`.

```cmake
cmake_minimum_required(VERSION 3.15)
project(SymbolRetentionExample LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(SymbolRetentionExample main.cpp)

# PDB generation with incremental linking and profile guided optimization.
if(CMAKE_BUILD_TYPE STREQUAL "Release")
  set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /Zi /PROFILE")
  set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} /DEBUG /INCREMENTAL /PROFILE")
  set_property(TARGET SymbolRetentionExample PROPERTY PDB_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/pdbs")
endif()

```
*Commentary*: Here, we're adding the `/PROFILE` flag to both the compiler and the linker. This flag is useful if you will be performing profile guided optimization, which requires debug symbols. Additionally, we're using `/INCREMENTAL`, which provides faster compilation times by only re-linking code that has changed. This is particularly important for release builds where compilation speed is paramount.  The `/Zi` and `/DEBUG` flags are retained for full symbol generation. `/PROFILE` requires the `/DEBUG` flag to also be present.

**Resource Recommendations**

To deepen understanding of debug symbol generation and management in the Windows environment, several resources are valuable.  Microsoft's official documentation on the C/C++ compiler and linker options is a primary source for specifics related to the `/Zi`, `/DEBUG`, `/INCREMENTAL` and `/PROFILE` switches. The documentation for the `PDB` file format can also be extremely useful. For working with CMake specifically, cross-referencing official CMake documentation regarding flags for compiler and linker settings can help maintain up to date configurations. Lastly, documentation or articles from the profiler being used (e.g. Intel VTune, Nvidia Nsight, or Windows Performance Analyzer (WPA)), is crucial to ensure the profiler is configured to use the PDB files.
