---
title: "How do I find the indices of specific values in a PyTorch tensor?"
date: "2025-01-30"
id: "how-do-i-find-the-indices-of-specific"
---
The efficiency of indexing operations on PyTorch tensors directly impacts the performance of deep learning models, especially when dealing with high-dimensional data. In my experience optimizing model training loops, locating indices of specific values frequently surfaced as a performance bottleneck. The solution involves leveraging PyTorch's functionalities to create boolean masks and subsequently extract the desired indices. This avoids costly Python-level iterations and operates directly within the optimized C++ backend of PyTorch.

Finding the indices of specific values within a PyTorch tensor is not directly achieved through a single built-in function that returns index tuples. Rather, the process requires a two-step approach using a combination of boolean masking and the `torch.nonzero` function. First, a boolean mask is generated by comparing the original tensor against the desired value or set of values. Subsequently, `torch.nonzero` extracts the indices of all `True` values within this mask.

The boolean mask generation is straightforward. If we seek indices where a tensor `x` is equal to a value `v`, we create a mask using `x == v`. This operation returns a tensor of boolean values, with `True` in locations where the condition holds and `False` elsewhere. The comparison is element-wise, and the resulting mask has the same shape as the original tensor. This step operates on the GPU if the original tensor is on the GPU. For more complex conditions, logical operators such as `&` (and), `|` (or), and `~` (not) can be used to build more elaborate masks, such as locating values within specific ranges or that satisfy more complicated criteria.

Once the boolean mask is generated, `torch.nonzero(mask)` returns a tensor of indices. Each row in this returned tensor represents the multi-dimensional index of a location where the mask was `True`. For a one-dimensional tensor, `torch.nonzero` will return a two-dimensional tensor, where the first column represents the indices of the desired values. For higher-dimensional tensors, each row of the returned tensor contains the multi-dimensional indices corresponding to each identified value. If no values matching the condition are found, the returned tensor will have a size of `[0, n]`, where `n` is the dimensionality of the input tensor. This behavior is important to consider when processing the results to avoid errors when the index tensor is empty. The returned tensor is always a `LongTensor` and resides on the same device (CPU or GPU) as the input mask.

It's critical to recognize that equality comparisons with floating-point numbers can sometimes be unreliable due to the nature of floating-point representation. If the values being compared are floating-point numbers, it is often necessary to incorporate a tolerance or use approximations when creating the boolean masks. Approaches like `torch.abs(x - v) < tolerance` to establish proximity, rather than relying on exact equality, can provide a more robust solution. This mitigates issues with rounding errors causing missed matches. Furthermore, for non-exact searches within numerical ranges, `torch.logical_and` with multiple boolean conditions can specify precise ranges.

Here are several code examples illustrating these principles:

**Example 1: Finding indices in a 1D tensor**

```python
import torch

# Create a 1D tensor
x = torch.tensor([1, 2, 3, 2, 4, 2, 5])
value_to_find = 2

# Generate the boolean mask
mask = x == value_to_find

# Get the indices using nonzero
indices = torch.nonzero(mask)

print("Original Tensor:", x)
print("Boolean Mask:", mask)
print("Indices of value:", value_to_find, ":", indices)

# Output:
# Original Tensor: tensor([1, 2, 3, 2, 4, 2, 5])
# Boolean Mask: tensor([False,  True, False,  True, False,  True, False])
# Indices of value: 2 : tensor([[1], [3], [5]])
```

In this example, we create a one-dimensional tensor and aim to find the indices of all elements equal to 2. The boolean mask identifies the positions where the value is 2, and `torch.nonzero` extracts these indices, represented as a 2D tensor where the first column is the 1D index location.

**Example 2: Finding indices in a 2D tensor**

```python
import torch

# Create a 2D tensor
x = torch.tensor([[1, 2, 3], [4, 2, 6], [7, 8, 2]])
value_to_find = 2

# Generate the boolean mask
mask = x == value_to_find

# Get the indices using nonzero
indices = torch.nonzero(mask)

print("Original Tensor:\n", x)
print("Boolean Mask:\n", mask)
print("Indices of value:", value_to_find, ":\n", indices)

# Output:
# Original Tensor:
#  tensor([[1, 2, 3],
#          [4, 2, 6],
#          [7, 8, 2]])
# Boolean Mask:
#  tensor([[False,  True, False],
#         [False,  True, False],
#         [False, False,  True]])
# Indices of value: 2 :
#  tensor([[0, 1],
#         [1, 1],
#         [2, 2]])
```

Here, we work with a two-dimensional tensor. `torch.nonzero` produces a tensor where each row contains the (row, column) indices corresponding to the location of the value 2. The first column is the row and the second is the column, allowing location identification within the 2D tensor structure.

**Example 3: Finding indices using range conditions**

```python
import torch

# Create a tensor of floating-point values
x = torch.tensor([1.1, 2.5, 3.7, 2.1, 4.9, 2.8, 5.0])
lower_bound = 2.0
upper_bound = 3.0

# Generate the boolean masks
mask_lower = x >= lower_bound
mask_upper = x <= upper_bound
mask_combined = mask_lower & mask_upper

# Get the indices using nonzero
indices = torch.nonzero(mask_combined)

print("Original Tensor:", x)
print("Combined Boolean Mask:", mask_combined)
print("Indices within the range [", lower_bound, ",", upper_bound, "]:", indices)

# Output:
# Original Tensor: tensor([1.1000, 2.5000, 3.7000, 2.1000, 4.9000, 2.8000, 5.0000])
# Combined Boolean Mask: tensor([False,  True, False,  True, False,  True, False])
# Indices within the range [ 2.0 , 3.0 ]: tensor([[1], [3], [5]])
```

In this example, we focus on finding indices of values within a numerical range. Two boolean masks are generated: one to identify values greater than or equal to `lower_bound`, and the other for values less than or equal to `upper_bound`. These masks are then combined using a logical `&` to produce a mask that identifies all values within the specified range. Again, `torch.nonzero` extracts the indices where the combined condition is true. This highlights the flexibility of the approach when dealing with more intricate conditions.

For further understanding of these functions and their associated intricacies, I would recommend consulting the official PyTorch documentation. Focus on the sections concerning basic tensor operations, indexing, and logical operations. Furthermore, reviewing the source code of relevant functions in the `torch` namespace on platforms such as GitHub can provide significant insights into the underlying implementation details. Specifically, familiarize yourself with documentation relating to `torch.Tensor`, comparison operators, logical operations (`torch.logical_and`, `torch.logical_or`), and `torch.nonzero`. Experimenting with various tensor types and structures will further strengthen your proficiency in using these tools efficiently.
