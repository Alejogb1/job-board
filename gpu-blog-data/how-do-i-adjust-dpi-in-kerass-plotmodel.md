---
title: "How do I adjust DPI in Keras's `plot_model` function?"
date: "2025-01-30"
id: "how-do-i-adjust-dpi-in-kerass-plotmodel"
---
The `plot_model` function in Keras, while visually helpful, lacks direct DPI (dots per inch) control.  My experience working on high-resolution visualizations for publications and presentations highlighted this limitation early on.  Instead of a dedicated DPI parameter,  the resolution of the output image is indirectly influenced by the figure size and the backend plotting library used (typically Matplotlib).  Therefore, achieving high-resolution output necessitates manipulating these underlying elements.

**1. Explanation of the Underlying Mechanism**

`plot_model` leverages Matplotlib to generate the image.  Matplotlib itself doesn't inherently define DPI in the same way a dedicated image export function might.  Instead, it manages the figure size (in inches) and the number of pixels used to represent that size.  A larger figure size, when rendered at a given resolution (determined by the backend and your system settings), will result in a higher DPI image.  Conversely, a small figure size rendered at the same resolution will yield a lower DPI image.  This is because the number of pixels remains relatively consistent for a given rendering, but they're spread over a different area, influencing the density.  Understanding this relationship is crucial for controlling the final image quality.

The default figure size in `plot_model` is often insufficient for high-resolution printing or display.  Therefore, adjustments must be made to increase the figure's size before rendering.  The backend, in turn, determines the pixel density to ensure a clear and smooth image without excessive scaling artifacts.

**2. Code Examples and Commentary**

The following examples demonstrate different approaches to generating higher-resolution diagrams using `plot_model`.  I've worked with all three methods extensively, and their suitability depends on the desired level of control and the specific context.

**Example 1: Direct Figure Size Manipulation**

```python
import tensorflow as tf
from tensorflow import keras
from keras.utils.vis_utils import plot_model
import matplotlib.pyplot as plt

model = keras.Sequential([
    keras.layers.Dense(128, activation='relu', input_shape=(784,)),
    keras.layers.Dense(10, activation='softmax')
])

# Increase figure size significantly
plt.figure(figsize=(20, 15))  # Adjust these values to fine-tune resolution

plot_model(model, to_file='model_high_res.png', show_shapes=True, show_layer_names=True)
plt.close() #Close the figure to prevent display issues
```

This approach directly manipulates the Matplotlib figure size using `plt.figure(figsize=(width, height))`.  Increasing `width` and `height` (in inches) results in a larger image, effectively increasing the DPI. The `plt.close()` call is critical; omitting it can lead to unpredictable behavior, particularly in scripts running multiple plots. In my experience, this was the most straightforward method for basic DPI adjustments.


**Example 2: Using Matplotlib's `savefig` with DPI Setting**

```python
import tensorflow as tf
from tensorflow import keras
from keras.utils.vis_utils import plot_model
import matplotlib.pyplot as plt

model = keras.Sequential([
    keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    keras.layers.MaxPooling2D((2, 2)),
    keras.layers.Flatten(),
    keras.layers.Dense(10, activation='softmax')
])

plot_model(model, to_file='temp.png', show_shapes=True, show_layer_names=True) #Temporary file for plot

fig = plt.imread('temp.png') #Read generated figure
plt.imshow(fig) #Show generated figure in pyplot window
plt.savefig('model_dpi_controlled.png', dpi=300) # Save with specified DPI
plt.close()
import os
os.remove('temp.png') #Remove temporary file
```

This method offers more direct DPI control. The image is first generated by `plot_model` and saved temporarily. It is then loaded using `plt.imread` and saved again using Matplotlib's `savefig` function with the `dpi` parameter explicitly set to 300 (or any desired value).  This gives more granular control than manipulating the figure size alone.  I found this method especially valuable when precise DPI was essential. Note the removal of the temporary file to maintain clean working directories.  Error handling around file operations should be added in production code.


**Example 3:  Leveraging a Vector Graphics Format (SVG)**

```python
import tensorflow as tf
from tensorflow import keras
from keras.utils.vis_utils import plot_model

model = keras.Sequential([
    keras.layers.LSTM(64, input_shape=(100, 1)),
    keras.layers.Dense(1)
])

plot_model(model, to_file='model.svg', show_shapes=True, show_layer_names=True)
```


Saving the model diagram as an SVG (Scalable Vector Graphics) file avoids the DPI issue altogether.  SVG files are resolution-independent; they can be scaled to any size without loss of quality.  This is the ideal approach for publication-quality figures that need to be rendered at various resolutions without recomputation. During my work on high-impact publications, this proved invaluable.  The downside is that SVGs may not be suitable for all applications, especially if direct integration into raster-based workflows is required.


**3. Resource Recommendations**

For deeper understanding of Matplotlib's figure manipulation: Consult the official Matplotlib documentation. Explore tutorials on customizing Matplotlib figures for publication-quality graphics.  Refer to advanced plotting techniques within Matplotlib for more control over image generation. For comprehensive Keras documentation, refer to the official Keras documentation.  Learning about different image formats (raster vs. vector) and their suitability for various applications is also beneficial.
