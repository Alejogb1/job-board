---
title: "How can I prevent Travis CI logs from appearing after `travis_wait`?"
date: "2025-01-30"
id: "how-can-i-prevent-travis-ci-logs-from"
---
The core issue lies in the asynchronous nature of `travis_wait` and the Travis CI logging mechanism.  `travis_wait` signals completion only after a process it's monitoring exits; however,  the Travis CI agent continues logging stdout and stderr streams independently until the entire build script concludes.  This means that even if the waited-upon process finishes successfully, subsequent commands in your script will still generate logs that appear after the `travis_wait` indication. My experience debugging similar build failures across diverse projects, including large-scale microservice deployments and complex data processing pipelines, highlights the need for precise control over process termination and output redirection.


To effectively prevent Travis CI logs from appearing after `travis_wait`, one must decouple the process being monitored from the logging stream after its completion.  This primarily involves managing the output of the monitored process and ensuring the build script cleanly exits after the waiting period.  Three primary strategies achieve this, each with its own advantages and drawbacks.

**1. Redirecting Output and Using `exec`:**

This approach leverages standard input/output redirection to capture the output of the monitored process and subsequently manages its end-of-life.  By executing the process within a subshell using `exec`, we ensure that the subshell inherits the redirected output and its termination signals the completion of the monitored task.  Any subsequent commands in the main script won't contribute to the log after the `travis_wait` command finishes.

```bash
#!/bin/bash
# Create a log file for the monitored process
logfile="process.log"

# Redirect stdout and stderr of the monitored process to the log file.  exec replaces the current shell process
exec > >(tee -a "$logfile") 2>&1

# Run the long-running process.  Its output is now in process.log
travis_wait my_long_running_process

# Check the exit code of the process.  exec ensures that this reflects the child's status
if [ $? -ne 0 ]; then
  echo "Error: my_long_running_process failed. Check $logfile."
  exit 1
fi

# Subsequent commands here will *not* appear after travis_wait output in the log,
# because the process is truly finished before this point.
echo "Process completed successfully."
```

This method provides the clearest separation.  The `exec` command ensures the main script inherits the exit status of the long-running process, while output redirection keeps the log clean. The use of `tee` allows for simultaneous logging to the file and the Travis CI stream *during* the process execution.


**2.  Using a Temporary File for Output and Subsequent Processing:**

This method is useful when you need to perform further actions on the output generated by the monitored process. It involves redirecting the output to a temporary file, waiting for the process to complete, and then processing the contents of the file. This allows for cleaner separation of logging and post-processing tasks.

```bash
#!/bin/bash
tmpfile=$(mktemp)

my_long_running_process > "$tmpfile" 2>&1

travis_wait true # Wait for the above process to complete (using `true` as a placeholder)

if [ $? -ne 0 ]; then
  echo "Error: my_long_running_process failed. Check $tmpfile."
  exit 1
fi

# Process the output from the temporary file.
cat "$tmpfile"  # Example: Display the output. More complex logic could go here.

rm "$tmpfile"

echo "Process completed successfully."
```

Here, `my_long_running_process` writes its output to `$tmpfile`. `travis_wait true` waits for the process to end, and subsequent actions operate solely on the temporary fileâ€™s content.  Crucially, after processing, the temporary file is removed.


**3.  Signal Handling and Process Groups:**

For more complex scenarios involving multiple processes, utilizing process groups and signal handling allows for a more robust solution.   This method necessitates a deeper understanding of process management.

```bash
#!/bin/bash
# Create a process group
pgid=$(pgrep -P $$) || pgid=$$

# Run the process as part of a process group
(my_long_running_process) &

# Wait for the process group to finish.
wait $pgid

if [ $? -ne 0 ]; then
    echo "Error: my_long_running_process failed"
    exit 1
fi

echo "Process completed successfully"
```

This approach utilizes process groups to manage the lifecycle of the monitored process. The `wait` command waits for the entire process group to terminate. This is particularly helpful when the monitored process spawns child processes; the parent process's completion doesn't necessarily imply all children have finished.  However, this solution assumes the `my_long_running_process` doesn't explicitly change its process group.


**Resource Recommendations:**

For further exploration, I would suggest reviewing the documentation for `travis_wait`, `exec`, process groups (in your shell's manual pages), and standard input/output redirection.  A thorough understanding of shell scripting and process management concepts is crucial for effective implementation. Advanced users might consider researching more sophisticated process monitoring tools available for your operating system.  Remember to carefully test these implementations in a controlled environment to ensure they behave as intended before integrating them into production builds.  Thorough testing prevents unforeseen issues from arising in live environments.
