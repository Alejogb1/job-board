---
title: "How do JFR ExecutionSample and ThreadDump differ?"
date: "2025-01-30"
id: "how-do-jfr-executionsample-and-threaddump-differ"
---
The fundamental distinction between a Java Flight Recorder (JFR) ExecutionSample event and a thread dump lies in their methodology, granularity, and the resulting data representation.  While both provide insights into application thread activity, JFR ExecutionSamples offer a statistically robust, low-overhead continuous profile, whereas thread dumps capture a snapshot of the JVM's thread state at a specific point in time.  This difference profoundly impacts their application in performance analysis and debugging.  My experience troubleshooting complex, high-throughput systems highlighted this distinction repeatedly.

**1. JFR ExecutionSample: Continuous Profiling**

JFR ExecutionSamples are events generated by JFR at configurable intervals.  Each sample represents a stack trace for a given thread at the time of sampling.  Crucially, these samples are collected continuously over a defined recording duration, offering a statistical overview of the application's execution.  Unlike thread dumps, which are triggered manually or by an external event (such as a memory leak), JFR samples create a time-series representation of thread activity. This allows for the identification of performance bottlenecks that might only manifest over time, rather than simply at a singular instant.  The low overhead associated with JFR event generation ensures minimal impact on the application's performance, making it suitable for long-term monitoring in production environments. The key is that the sampling frequency dictates the granularity of the analysis; higher sampling rates provide more precise detail but increase the overhead.  In my experience optimizing a real-time bidding system,  carefully balancing sampling rate and recording duration was key to obtaining meaningful results without significantly affecting the system's responsiveness.


**2. Thread Dump: Instantaneous Snapshot**

A thread dump, on the other hand, provides a snapshot of the JVM's thread state at a precise moment.  It lists all running threads, including their stack traces, thread IDs, and states (e.g., RUNNING, BLOCKED, WAITING).  Thread dumps are valuable for identifying deadlocks, examining thread states during unexpected crashes, or pinpointing the source of long-running operations that appear unexpectedly.  However, because they represent a single point in time, they cannot reveal temporal patterns in thread behavior.  A single thread dump might show a thread blocked on I/O, but it cannot definitively state whether this is a transient condition or a systemic problem.  Multiple thread dumps taken over time can provide some temporal context, but they lack the statistical rigor of JFR's continuous profiling.  Iâ€™ve used thread dumps countless times during emergency debugging sessions, particularly when faced with unresponsive applications or resource exhaustion.  The immediate, comprehensive view of thread activity they provide is invaluable in such situations.


**3. Code Examples and Commentary**

To illustrate the differences, let's consider three scenarios and how each technique would be applied.

**Example 1: Identifying a Long-Running Thread using JFR**

```java
// Assuming a JFR recording is already configured and running.  This code would not directly generate the JFR data.  
//The data would be analyzed post recording.  This shows conceptual use.

//This is an illustration within the application for context.  A performance issue is actually triggered separately.
public void longRunningTask() {
    try {
        Thread.sleep(10000); // Simulates a long-running task
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}

//Analyzing JFR data would reveal the long-running thread based on sample frequency and cumulative execution time.

//Post-recording Analysis (using JFR tools):
//Examine the aggregated ExecutionSample data to identify the method longRunningTask() and analyze its frequency and durations across the recording.
```

This example highlights JFR's strength in identifying performance bottlenecks over time.  By examining the aggregate execution time of `longRunningTask()` across multiple ExecutionSamples, one could quantify its contribution to overall performance degradation. A single thread dump, on the other hand, might only capture this thread mid-execution, lacking the broader context.

**Example 2: Detecting a Deadlock using Thread Dump**

```java
//Illustrative Deadlock scenario
public class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized (lock1) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // Handle the exception
            }
            synchronized (lock2) {
                // ... some code
            }
        }
    }

    public void method2() {
        synchronized (lock2) {
            synchronized (lock1) {
                // ... some code
            }
        }
    }
    public static void main(String[] args) throws InterruptedException{
        DeadlockExample deadlockExample = new DeadlockExample();
        new Thread(deadlockExample::method1).start();
        new Thread(deadlockExample::method2).start();
        Thread.sleep(2000);
    }

}
```

By triggering a thread dump during the execution of this code, one would clearly observe the deadlock condition, with two threads holding locks on each other.  JFR wouldn't directly detect a deadlock; its data would, however, show both threads being blocked for extended periods, leading one to subsequently take a thread dump for root cause diagnosis.


**Example 3: Investigating a Crash with Thread Dump and JFR**

```java
// Example of a crash situation.
public class CrashExample {
    public static void main(String[] args) {
        int[] array = new int[10];
        System.out.println(array[10]); // Attempt to access an out-of-bounds index
    }
}
```

In this scenario, a thread dump immediately after the crash would show the thread that caused the exception (ArrayIndexOutOfBoundsException) and its call stack. JFR, if it had been running, would provide further context leading up to the crash.  Specifically, one could examine the thread activity prior to the crash, potentially identifying performance issues or patterns that contributed to the error. The JFR data provides a retrospective look at potential precursors, whereas the thread dump focuses on the immediate point of failure.


**4. Resource Recommendations**

For deeper understanding of JFR, consult the official Java documentation on Java Mission Control and Java Flight Recorder.  For effective thread dump analysis, explore resources dedicated to JVM debugging and performance tuning techniques.  Understanding the limitations and strengths of both tools through practical use cases, including simulated and real-world issues, is crucial for a skilled analyst.

In conclusion,  JFR ExecutionSamples and thread dumps are complementary tools. JFR offers continuous profiling for identifying performance issues over time, while thread dumps provide instantaneous snapshots of thread activity ideal for diagnosing deadlocks, and analyzing crash scenarios.  Choosing the appropriate tool, or indeed, leveraging both in tandem, depends on the specific context of the performance or debugging problem at hand.  The integration of both into an effective diagnostic strategy is what separates effective troubleshooting from trial-and-error debugging.
