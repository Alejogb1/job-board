---
title: "Why do async functions with two non-static and one static references fail to compile?"
date: "2025-01-30"
id: "why-do-async-functions-with-two-non-static-and"
---
The core issue stems from Rust's ownership and borrowing rules, specifically when dealing with async functions that capture variables with varying lifetimes in the context of a generated state machine. This state machine, created under the hood by the `async` keyword, needs to store captured variables across suspension points within the function. Non-static references, tied to the lifetime of their containing scope, create challenges when the async function's lifetime might extend beyond that containing scope. Let’s examine this phenomenon in detail.

Async functions in Rust do not execute synchronously. Instead, they return a `Future` that represents the asynchronous computation. When this `Future` is awaited, the compiler generates a state machine. This state machine essentially encapsulates the function's execution state, allowing it to pause, store variables, and resume later, often when an I/O operation completes. References, in particular, require meticulous handling as they are tied to the lifetime of the data they point to. When an async function captures references, the state machine must ensure that those references remain valid for as long as the `Future` is alive. This is where the problem with non-static and static references mixes comes into play.

A static reference `'static` is a reference with a lifetime that persists for the entire duration of the program's execution. A non-static reference has a lifetime tied to a specific scope, often the function it's defined in or the struct it's associated with. When an async function captures a mix of both, the compiler must reconcile these differing lifetimes within the generated state machine. If a non-static reference is captured, its lifetime must be extended to at least that of the `Future` itself. However, this can lead to an incompatibility. Consider a non-static reference to a local variable. When the function containing that variable exits, the variable is no longer valid, even if the `Future` created within the function is still being awaited. The compiler, enforcing Rust's memory safety guarantees, detects this potential dangling reference, preventing compilation. The presence of a static reference does not negate this issue; it's more about the fact non-static references create a dependency which can't be resolved.

The error isn't due to a limitation on static references themselves, but the inability of the compiler to guarantee the validity of the non-static ones across potentially extended asynchronous operations. Let’s look at some code examples to clarify.

**Example 1: Demonstrating the Failure**

```rust
async fn invalid_capture() {
    let data1 = String::from("Non-static 1");
    let data2 = String::from("Non-static 2");
    static STATIC_DATA: &str = "Static Data";

    async move {
      println!("{}, {}, {}", data1, data2, STATIC_DATA); // Error here
    }.await;
}

fn main() {
  tokio::runtime::Builder::new_multi_thread()
      .enable_all()
      .build()
      .unwrap()
      .block_on(invalid_capture());
}
```

This code snippet will fail to compile. The inner `async move` block attempts to capture `data1` and `data2` by value, and `STATIC_DATA` by reference. The problem arises because `data1` and `data2` are owned by the scope of `invalid_capture` and thus their lifetimes may not cover the future generated by `async move`. The `move` keyword also does not help here; since it means moving the ownership to the closure, and not to the internal state machine. Even though it does not appear in the code directly, the generated state machine must capture non-static references correctly, the compiler must ensure that `data1` and `data2` will be available if the `Future` is evaluated later (when the `await` point is reached). This is not guaranteed; thus compilation will fail. The compiler, in its wisdom, has detected this potential use-after-free situation. Even though `STATIC_DATA` is valid for the entire program’s runtime, this doesn't solve the issue of non-static data.

**Example 2: Corrected Code Using Ownership**

```rust
async fn valid_capture() {
    let data1 = String::from("Non-static 1");
    let data2 = String::from("Non-static 2");
    static STATIC_DATA: &str = "Static Data";

    let future = async move {
        println!("{}, {}, {}", data1, data2, STATIC_DATA); // All good
    };

    future.await;
}

fn main() {
  tokio::runtime::Builder::new_multi_thread()
      .enable_all()
      .build()
      .unwrap()
      .block_on(valid_capture());
}
```

This version resolves the compilation error by explicitly using `async move` to transfer ownership of `data1` and `data2` to the closure. This action ensures that the `Future` has a copy (or moved version) of `data1` and `data2`. The lifetime of the copies becomes tied to the `Future`’s lifetime. The `STATIC_DATA` reference is also moved but the underlying static string exists through the program's lifespan so it's always safe to access. The state machine, when generated, will therefore store its copy of `data1` and `data2`, resolving the potential dangling pointer issue. This illustrates that transferring ownership, not borrowing, is the way to capture local variables in an async context.

**Example 3: Using a Struct for Shared Mutable State**

```rust
use std::sync::{Arc, Mutex};

struct SharedData {
  data1: String,
  data2: String
}

async fn shared_state_example() {
    let shared_data = Arc::new(Mutex::new(SharedData{
        data1: String::from("Non-static 1"),
        data2: String::from("Non-static 2")
    }));
    
    static STATIC_DATA: &str = "Static Data";

    let shared_data_clone1 = shared_data.clone();
    let shared_data_clone2 = shared_data.clone();
    
    let future1 = async move {
      let data = shared_data_clone1.lock().unwrap();
        println!("{}, {}, {}", data.data1, data.data2, STATIC_DATA);
    };

    let future2 = async move {
        let data = shared_data_clone2.lock().unwrap();
      println!("{}, {}, {}", data.data1, data.data2, STATIC_DATA);
    };

  tokio::join!(future1, future2);
}

fn main() {
  tokio::runtime::Builder::new_multi_thread()
      .enable_all()
      .build()
      .unwrap()
      .block_on(shared_state_example());
}

```

This third example demonstrates a more complex, but realistic scenario. If you need to have shared, mutable data that is referenced by multiple asynchronous tasks, you'll need a mechanism for synchronizing access. We can use `Arc` and `Mutex` to create such shared state. Each async block now clones the `Arc` and subsequently locks the `Mutex` to access the data. This pattern ensures both thread-safety and avoids the lifetime issues that arise from borrowing non-static variables. The static reference is simply captured, but it’s not an issue in this context as we know it is always valid. Using `Arc` and `Mutex` we move the allocation of non-static variables into shared memory, whose lifetime is greater than the generated future. Thus each of the asynchronous tasks gets a unique, mutable, copy of the `Arc` pointer, which can safely dereference.

When building asynchronous applications in Rust, understanding the interplay between ownership, borrowing, and asynchronous state machines is essential. As these examples show, moving ownership of variables or allocating them in shared memory using tools like `Arc<Mutex<T>>` are the correct approach. Attempting to borrow non-static variables directly within an async context will lead to compiler errors, due to lifetime incompatibilities.

For further understanding of these concepts, I would suggest consulting documentation on Rust ownership and borrowing. Specifically, delve into the material on closures and how they capture their environment. Examine the documentation on the `async` and `await` keywords and how they transform functions into state machines. Finally, familiarize yourself with smart pointers in Rust, like `Arc`, which enable shared ownership. Look into the tokio documentation for examples on how to handle state using `Arc<Mutex<T>>` which is a common pattern for shared state across multiple asynchronous tasks. These resources will provide a solid foundation for tackling complex asynchronous scenarios.
