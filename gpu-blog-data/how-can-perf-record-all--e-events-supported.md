---
title: "How can perf record all -e events supported by GCC's -fauto-profile?"
date: "2025-01-30"
id: "how-can-perf-record-all--e-events-supported"
---
The `perf record` utility, coupled with GCC's `-fauto-profile`, offers a powerful, albeit nuanced, approach to performance analysis.  A crucial detail often overlooked is that `-fauto-profile` generates profile data in a specific format, not directly interpretable by `perf`'s default event selection.  It requires a two-stage process: profile data generation followed by its consumption for event selection within `perf`.  Directly using `perf record -e` with all supported events post-compilation is ineffective; it will not leverage the auto-profile data. My experience working on high-performance computing projects has highlighted this distinction repeatedly.

**1. Clear Explanation:**

GCC's `-fauto-profile` generates an instrumentation file, typically named `*.auto.profraw`, containing execution counts for basic blocks within the compiled program. This data is then processed by `llvm-profdata` to create a more structured profile, usually a `.profdata` file.  This `.profdata` file isn't directly consumed by `perf`. Instead, it informs the subsequent `perf record` command on *which* events to prioritize.  The critical step lies in strategically leveraging the profile data to guide `perf`'s event selection, allowing for a more targeted and efficient profiling session.  Attempting to record *all* events indiscriminately, particularly those potentially generated in vast quantities by heavily profiled functions, leads to excessive overhead and potentially incomplete or unusable data.  The focus should be on identifying performance bottlenecks using the profile data, then recording only the events related to those bottlenecks.


**2. Code Examples with Commentary:**

**Example 1:  Generating the Profile Data**

```c++
#include <iostream>
#include <vector>

int main() {
  std::vector<int> data(1000000);
  for (int i = 0; i < 1000000; ++i) {
    data[i] = i * 2;
  }
  int sum = 0;
  for (int i = 0; i < 1000000; ++i) {
    sum += data[i];
  }
  std::cout << "Sum: " << sum << std::endl;
  return 0;
}
```

Compilation with auto-profiling enabled:

```bash
g++ -fauto-profile -o myprogram myprogram.cpp
./myprogram
```

This generates `myprogram.auto.profraw`.  The subsequent steps are crucial to utilize this data effectively with `perf`.


**Example 2:  Generating the Profile and Listing Hot Functions**

```bash
llvm-profdata merge -output=myprogram.profdata myprogram.auto.profraw
llvm-profdata show myprogram.profdata
```

The `llvm-profdata merge` command creates the `.profdata` file. The `llvm-profdata show` command displays a summary of the hot functions. This allows us to identify which parts of the code warrant more detailed profiling with `perf`.  For instance, if the loop in `main` shows up as a hot function, we can select events targeting that section for improved efficiency.


**Example 3: Targeted Perf Recording Based on Profile Data**

Let's assume the `llvm-profdata show` command highlighted the loop in `main` as a hot function. We can then tailor `perf record` to focus on events relevant to that section.  This example focuses on instructions and cache misses â€“ events directly related to CPU utilization:


```bash
perf record -e instructions,cache-misses -p $(pidof myprogram)
perf report
```

This uses the process ID (`pidof myprogram`) to directly profile the running instance of our program, targeting specific events instead of recording all events indiscriminately.   The `perf report` command then presents the data, showing, for example, a high number of instructions and cache misses within the identified hot loop in `main`. This highly targeted approach avoids the overhead of recording unnecessary events and yields more meaningful data.  Note that replacing `$(pidof myprogram)` with the actual PID would be necessary for shell scripts.


**3. Resource Recommendations:**

*   The GCC manual, specifically the sections detailing `-fauto-profile` and related options.
*   The LLVM documentation pertaining to `llvm-profdata`.
*   The `perf` manual pages, including details on event selection and filtering.
*   A comprehensive guide to performance analysis using `perf` (a book or online tutorial).  This would provide deeper insight into effective data interpretation.


In conclusion, effectively utilizing `perf` with GCC's `-fauto-profile` requires a multi-stage process.  The crucial aspect is using the profile data generated by `-fauto-profile` and `llvm-profdata` to intelligently select events for recording with `perf`, resulting in a more focused and efficient analysis.  Directly attempting to record all events is inefficient and produces overwhelming, often unusable data. My experience emphasizes the necessity of a targeted approach driven by initial profile data analysis.  This method significantly improves accuracy and usability in performance investigations.
