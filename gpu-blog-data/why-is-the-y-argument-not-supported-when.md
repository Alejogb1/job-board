---
title: "Why is the `y` argument not supported when using `keras.utils.Sequence` in TensorFlow?"
date: "2025-01-30"
id: "why-is-the-y-argument-not-supported-when"
---
TensorFlow's `keras.utils.Sequence` is fundamentally designed as a generator of batches, focusing solely on input data (`x`) and leaving label handling to the model training process. This is a departure from array-based data loading where `x` and `y` are typically processed together. The core rationale is to enhance flexibility and scalability, especially when dealing with large datasets or complex data pipelines. Unlike passing both `x` and `y` in one call, `Sequence` decouples input data loading from output label generation, allowing for asynchronous, on-the-fly augmentation, processing, and even dynamically generated labels. This architectural decision, while initially perplexing, optimizes resource usage and accommodates a broader range of use cases.

The absence of a direct `y` argument within the `__getitem__` method of `keras.utils.Sequence` stems from the desire to separate data retrieval from data labeling. The `__getitem__` method is primarily responsible for fetching the input data batch (defined by the batch index). How and where these batches are subsequently paired with their corresponding labels is the responsibility of the model training loop or a custom data pipeline. This separation facilitates scenarios where labels might be derived from the input data itself, generated by an external process, or even modified dynamically during training (e.g., label smoothing).

Consider a typical image classification problem. Instead of pre-loading all images and their labels into memory, a `Sequence` can load only the images required for the current batch. The labels corresponding to these images can then be retrieved or generated separately during model training. This strategy minimizes memory footprint and maximizes efficiency, especially with large image datasets. Further, it promotes reusability as a single `Sequence` can be employed for data loading, regardless of the specific label structure used by the model.

To clarify, consider three examples, each building on the core principles.

**Example 1: Simple Image Loading and Label Generation**

Assume a directory structure where each class has its own subdirectory containing images. The labels are integer representations of these classes. This example uses basic operations: loading the image by path, basic resizing, and one-hot encoding the labels.

```python
import os
import numpy as np
import tensorflow as tf
from tensorflow.keras.utils import Sequence

class ImageSequence(Sequence):
    def __init__(self, image_dir, batch_size, img_height, img_width, class_names):
        self.image_dir = image_dir
        self.batch_size = batch_size
        self.img_height = img_height
        self.img_width = img_width
        self.class_names = class_names
        self.image_paths = []
        for class_name in class_names:
            class_dir = os.path.join(image_dir, class_name)
            for filename in os.listdir(class_dir):
                if filename.lower().endswith(('.png', '.jpg', '.jpeg')):
                  self.image_paths.append(os.path.join(class_dir, filename))
        self.n_images = len(self.image_paths)
        self.n_classes = len(self.class_names)

    def __len__(self):
        return int(np.ceil(self.n_images / float(self.batch_size)))

    def __getitem__(self, idx):
        batch_paths = self.image_paths[idx * self.batch_size : (idx + 1) * self.batch_size]
        batch_x = []
        batch_y = []
        for path in batch_paths:
            image = tf.io.read_file(path)
            image = tf.image.decode_image(image, channels=3)
            image = tf.image.resize(image, [self.img_height, self.img_width])
            image = image / 255.0
            batch_x.append(image)
            label = self.class_names.index(os.path.basename(os.path.dirname(path))) # Extract the class label from the directory
            batch_y.append(tf.one_hot(label, depth=self.n_classes))

        return np.stack(batch_x), np.stack(batch_y) #Explicitly return x, y tuple for use in training loop
```
In this example, the `__getitem__` method loads the images (`batch_x`) and constructs corresponding one-hot encoded labels (`batch_y`). Note how the label is derived from the image path â€“ the location of image on file system dictates its label, not being passed in directly. It then explicitly returns the tuple `(batch_x, batch_y)`.  This illustrates that while `Sequence` itself doesn't support a `y` argument, you can construct the label within the `__getitem__` and return it. The training loop receives both in the format (x, y).

**Example 2: Dynamic Label Generation Based on Input**

Consider a case where labels need to be constructed based on the content of the input images.  For example, a computer vision model which needs to detect objects and create bounding box coordinates.  Here, the class labels and bounding boxes are generated dynamically from the image file.

```python
import os
import numpy as np
import tensorflow as tf
import json
from tensorflow.keras.utils import Sequence

class ObjectDetectionSequence(Sequence):
    def __init__(self, image_dir, annotation_dir, batch_size, img_height, img_width, class_names):
        self.image_dir = image_dir
        self.annotation_dir = annotation_dir
        self.batch_size = batch_size
        self.img_height = img_height
        self.img_width = img_width
        self.class_names = class_names
        self.image_paths = []
        for filename in os.listdir(image_dir):
            if filename.lower().endswith(('.png', '.jpg', '.jpeg')):
              self.image_paths.append(os.path.join(image_dir, filename))
        self.n_images = len(self.image_paths)
        self.n_classes = len(self.class_names)

    def __len__(self):
        return int(np.ceil(self.n_images / float(self.batch_size)))

    def __getitem__(self, idx):
      batch_paths = self.image_paths[idx * self.batch_size : (idx + 1) * self.batch_size]
      batch_x = []
      batch_y = []

      for path in batch_paths:
        image = tf.io.read_file(path)
        image = tf.image.decode_image(image, channels=3)
        image = tf.image.resize(image, [self.img_height, self.img_width])
        image = image / 255.0
        batch_x.append(image)

        annotation_path = os.path.join(self.annotation_dir, os.path.splitext(os.path.basename(path))[0] + '.json')
        with open(annotation_path, 'r') as f:
            annotation = json.load(f)
        
        #Process the annotations
        labels = []
        boxes = []

        for obj in annotation['objects']:
            labels.append(tf.one_hot(self.class_names.index(obj['class']), depth=self.n_classes))
            xmin = obj['bounding_box']['xmin'] / annotation['image_width']
            xmax = obj['bounding_box']['xmax'] / annotation['image_width']
            ymin = obj['bounding_box']['ymin'] / annotation['image_height']
            ymax = obj['bounding_box']['ymax'] / annotation['image_height']
            boxes.append(tf.constant([xmin, ymin, xmax, ymax], dtype = tf.float32))

        batch_y.append({'class_labels': np.stack(labels), 'bounding_boxes': np.stack(boxes)})


      return np.stack(batch_x), batch_y
```
Here, the `__getitem__` method still loads `batch_x`.  However, the corresponding `batch_y` is now a structure of label and bounding box information.  The label generation relies on the content of a json file, not directly on the file path as before. This highlights how data loading and label generation are flexible.  Note the explicit return of `(batch_x, batch_y)`.

**Example 3:  Augmentation Within the Sequence**

In many tasks data augmentation can be used to increase the robustness of the model.  This can be done within the `Sequence` class, meaning that every training batch is unique, rather than having to store augmented examples on disk or in memory.  Here we augment using an image rotation.

```python
import os
import numpy as np
import tensorflow as tf
import random
from tensorflow.keras.utils import Sequence

class AugmentingImageSequence(Sequence):
    def __init__(self, image_dir, batch_size, img_height, img_width, class_names):
        self.image_dir = image_dir
        self.batch_size = batch_size
        self.img_height = img_height
        self.img_width = img_width
        self.class_names = class_names
        self.image_paths = []
        for class_name in class_names:
            class_dir = os.path.join(image_dir, class_name)
            for filename in os.listdir(class_dir):
                if filename.lower().endswith(('.png', '.jpg', '.jpeg')):
                  self.image_paths.append(os.path.join(class_dir, filename))
        self.n_images = len(self.image_paths)
        self.n_classes = len(self.class_names)


    def __len__(self):
        return int(np.ceil(self.n_images / float(self.batch_size)))

    def __getitem__(self, idx):
      batch_paths = self.image_paths[idx * self.batch_size : (idx + 1) * self.batch_size]
      batch_x = []
      batch_y = []
      for path in batch_paths:
            image = tf.io.read_file(path)
            image = tf.image.decode_image(image, channels=3)
            image = tf.image.resize(image, [self.img_height, self.img_width])
            image = image / 255.0

            #Random rotation of image as augmentation
            angle = random.uniform(-20, 20) # Random rotation angle
            image = tf.image.rotate(image, tf.constant(angle * np.pi / 180.0))

            batch_x.append(image)
            label = self.class_names.index(os.path.basename(os.path.dirname(path)))
            batch_y.append(tf.one_hot(label, depth=self.n_classes))
      return np.stack(batch_x), np.stack(batch_y)
```
The fundamental loading and label generation is the same as the first example, except that here each image is rotated by a random amount within the `__getitem__` method. Again, we explicitly return `(batch_x, batch_y)`.

In summary, `keras.utils.Sequence` is designed to handle the retrieval and processing of input data batches, while deferring the pairing of data with labels. This approach enhances the flexibility, efficiency and scalability of data pipelines. The examples demonstrate how label generation, augmentation and complex data structures can be incorporated into the `__getitem__` method.

For further exploration, consider reviewing the TensorFlow documentation on `tf.data` which provides an alternative data loading and manipulation framework. The book "Deep Learning with Python" (2nd edition) by Francois Chollet also discusses `Sequence` objects in detail.  Furthermore, tutorials focusing on TensorFlow data loading, available from the TensorFlow website, offer valuable practical guidance. Examining practical examples of custom `Sequence` implementations, often found on Github, will provide deeper insight. These resources should strengthen understanding of the design choices behind the `Sequence` class.
