---
title: "Can Bazel packages depend on source files in other packages?"
date: "2025-01-30"
id: "can-bazel-packages-depend-on-source-files-in"
---
Bazel's dependency management operates fundamentally differently than traditional build systems like Make or CMake.  Direct dependency on source files across packages is explicitly discouraged and, in most cases, impossible.  This stems from Bazel's inherent reliance on hermeticity and reproducibility, which are undermined by loose coupling of source code between packages.  My experience working on large-scale projects at Xylos Corporation highlighted the critical importance of adhering to Bazel's package structure conventions to maintain build stability and scalability.

**1.  Explanation of Bazel's Package Dependency Model**

Bazel's strength lies in its ability to create reproducible builds.  It achieves this through a strict dependency management system based on declared dependencies between *packages*, not individual files.  Each package is a self-contained unit, represented by a `BUILD` file.  This `BUILD` file defines the targets (libraries, binaries, tests, etc.) within the package and their dependencies on other packages.  Crucially, these dependencies are specified using the package's name, not the path to individual source files.

The reason for this restriction is twofold.  Firstly, it ensures hermeticity.  Bazel's build actions are solely determined by the package dependencies declared in the `BUILD` file and the content of the package's sources.  This eliminates the risk of accidental dependencies caused by implicit file inclusions or changes in file paths.  Secondly, it contributes to build reproducibility.  Since build actions are solely based on package dependencies, identical dependency configurations always produce identical results regardless of the environment or build machine.

Attempting to directly reference source files from one package within another introduces several problems.  The build will become non-hermetic as the build process will rely on implicitly defined file paths.  Moreover, code refactoring or changes to the project's structure might break dependencies unexpectedly.  This is particularly problematic in large-scale projects, where unforeseen side effects can easily arise.  Furthermore, the build system loses track of dependencies, hindering parallel builds and incremental compilation, thus negating one of Bazel's key performance advantages.

Therefore, to establish a dependency, you must define appropriate targets (e.g., libraries, rules) within the respective packages and declare dependencies between these targets in the `BUILD` files.  Bazel's dependency resolution mechanism then ensures the correct build order and propagation of dependencies.


**2. Code Examples and Commentary**

Let's illustrate this with three examples demonstrating the correct approach to inter-package dependencies.

**Example 1:  Simple Library Dependency**

```bazel
# Package: lib/mylib
# BUILD file: lib/mylib/BUILD

load("@rules_cc//cc:defs.bzl", "cc_library")

cc_library(
    name = "mylib",
    srcs = ["mylib.cc"],
    hdrs = ["mylib.h"],
)
```

```bazel
# Package: app/myapp
# BUILD file: app/myapp/BUILD

load("@rules_cc//cc:defs.bzl", "cc_binary")
load(":mylib.bzl", "mylib")  # Import the library target definition


cc_binary(
    name = "myapp",
    srcs = ["myapp.cc"],
    deps = [":mylib"], # Dependency on the mylib library target
)
```

Here, `myapp` depends on `mylib`, not on specific files within `mylib`. The `deps` attribute specifies the dependency on the `mylib` target defined in the `lib/mylib/BUILD` file.  This approach promotes modularity, and the build system understands the precise dependency relationship, enabling optimizations and correctness.

**Example 2:  Dependency on a Generated File**

```bazel
# Package: data/generated
# BUILD file: data/generated/BUILD

load("@rules_python//python:defs.bzl", "py_binary")
load("@rules_python//python:defs.bzl", "py_library")

py_binary(
    name = "generate_data",
    srcs = ["generate_data.py"],
    main = "generate_data.py",
    deps = [":data_generator"]
)

py_library(
    name = "data_generator",
    srcs = ["data_generator.py"],
)

genrule(
    name = "generated_data",
    outs = ["data.txt"],
    cmd = "python3 $(location :generate_data) > $@",
)
```

```bazel
# Package: app/myapp
# BUILD file: app/myapp/BUILD

load("@rules_cc//cc:defs.bzl", "cc_binary")

cc_binary(
    name = "myapp",
    srcs = ["myapp.cc"],
    data = [":generated_data"], #Include generated file as data
)
```

In this case, `myapp` requires `data.txt`, a file generated by a rule in another package.  `myapp` doesn't depend on the generation process; it only depends on the existence of the generated `data.txt` file, included using the `data` attribute.  The dependency graph remains clear and reproducible, reflecting only the explicit relationship with the generated output.


**Example 3:  Using a custom rule**

```bazel
# Package: utils/myrule
# BUILD file: utils/myrule/BUILD

load("@rules_cc//cc:defs.bzl", "cc_library")

def _myrule_impl(ctx):
    # Implementation details...
    # ...

myrule = rule(
    implementation = _myrule_impl,
    attrs = {
        "srcs": attr.label_list(allow_single_file = True),
        "_my_attr": attr.string(), # Example of a custom attribute
    },
)
```

```bazel
# Package: app/myapp
# BUILD file: app/myapp/BUILD

load("//utils/myrule:myrule.bzl", "myrule")

myrule(
    name = "my_custom_target",
    srcs = glob(["*.txt"]),  #Note: this is within the current package
    _my_attr = "some_value"
)
```

Here, `myapp` uses a custom rule (`myrule`) defined in a separate package.  The custom rule itself can process sources; however, the dependencies remain explicitly managed through the `myrule` target.  The `srcs` attribute within `myrule` is bound to the package it is declared in. Even though this rule can be used in multiple places, the exact dependency on its source files is well-defined by where the rule is declared and its `srcs` attribute.

**3. Resource Recommendations**

I strongly recommend familiarizing yourself with the official Bazel documentation, paying close attention to the sections on package structure, dependencies, and rules.  Secondly, reviewing example Bazel projects (available through various open-source projects) can provide valuable practical insights.  Finally, explore advanced Bazel features like custom rules and aspects to manage more complex dependencies effectively.  These resources, combined with diligent practice, will significantly enhance your understanding and proficiency in using Bazel's dependency management.
